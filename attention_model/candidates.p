(dp0
I379906
c__builtin__
set
p1
((lp2
S'def num(s):\n    pass'
p3
aS'return False'
p4
aS'return float(s)'
p5
aS"a = '545.2222'"
p6
aS'float(value)'
p7
aS"a = '545.2222'\nfloat(a)\nint(float(a))"
p8
aS'return True'
p9
aS'float(a)\nint(float(a))'
p10
aS'float(a)'
p11
aS"a = '545.2222'\nfloat(a)"
p12
aS'return int(s)'
p13
aS'int(float(a))'
p14
aS'def isfloat(value):\n    pass'
p15
atp16
Rp17
sI3437059
g1
((lp18
S's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p19
aS"if (s.find('is') == (-1)):\n    pass"
p20
aS"if ('blah' not in somestring):\n    continue"
p21
aS's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p22
aS"if ('blah' not in somestring):\n    pass"
p23
aS'print "No \'is\' here!"'
p24
aS'continue'
p25
aS"s = 'This be a string'\nif (s.find('is') == (-1)):\n    pass"
p26
aS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p27
aS"s = 'This be a string'"
p28
aS'print "Found \'is\' in the string."'
p29
aS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p30
atp31
Rp32
sI4265988
g1
((lp33
S'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p34
aS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]'
p35
aS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p36
aS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p37
aS'numpy.random.choice(numpy.arange(1, 7), p=[0.1, 0.05, 0.05, 0.2, 0.4, 0.2])'
p38
aS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p39
aS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p40
aS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0'
p41
aS'if (s >= r):\n    return item'
p42
aS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p43
aS's += prob'
p44
aS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p45
aS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p46
aS'if (s >= r):\n    return item\nreturn item'
p47
aS'R = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p48
aS'for (item, prob) in l:\n    pass'
p49
aS'r = random.uniform(0, 1)'
p50
aS'def random_distr(l):\n    pass'
p51
aS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p52
aS's = 0'
p53
aS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p54
aS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob'
p55
aS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p56
aS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p57
aS'for (item, prob) in l:\n    s += prob'
p58
aS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    pass'
p59
aS's = 0\nfor (item, prob) in l:\n    s += prob'
p60
aS'return item'
p61
aS'sorted((max((i for r in [random.random()] for (i, c) in cdf if (c <= r))) for _ in range(1000)))'
p62
aS'def random_distr(l):\n    r = random.uniform(0, 1)'
p63
aS'if (s >= r):\n    pass'
p64
aS's = 0\nfor (item, prob) in l:\n    pass'
p65
aS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p66
atp67
Rp68
sI843277
g1
((lp69
S'my_variable = None'
p70
aS'def InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p71
aS'my_variable = None\n\ndef InitMyVariable():\n    pass'
p72
aS'def InitMyVariable():\n    global my_variable'
p73
aS'try:\n    myVar\nexcept NameError:\n    myVar = None'
p74
aS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable'
p75
aS"if ('myVar' in globals()):\n    pass"
p76
aS'def InitMyVariable():\n    pass'
p77
aS'myVar = None'
p78
aS'if (my_variable is None):\n    pass'
p79
aS'try:\n    myVar\nexcept NameError:\n    pass'
p80
aS'global my_variable'
p81
aS'pass'
p82
aS'myVar'
p83
aS"if ('myVar' in locals()):\n    pass"
p84
aS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p85
aS"if hasattr(obj, 'attr_name'):\n    pass"
p86
atp87
Rp88
sI546321
g1
((lp89
S'import datetime'
p90
aS'from datetime import date'
p91
aS'six_months = (date.today() + relativedelta(months=(+ 6)))'
p92
aS'print (datetime.date.today() + datetime.timedelta(((6 * 365) / 12))).isoformat()'
p93
aS'from datetime import date\nfrom dateutil.relativedelta import relativedelta'
p94
aS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))'
p95
aS'(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p96
aS'(day, month, year) = (day, ((month + 6) % 12), (year + ((month + 6) / 12)))'
p97
aS'from dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p98
aS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))\n(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p99
aS'from dateutil.relativedelta import relativedelta'
p100
aS'from datetime import date\nfrom dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p101
aS'import datetime\nprint (datetime.date.today() + datetime.timedelta(((6 * 365) / 12))).isoformat()'
p102
aS'date += datetime.timedelta((6 * 30))'
p103
atp104
Rp105
sI237079
g1
((lp106
S'def modification_date(filename):\n    pass'
p107
aS"if (platform.system() == 'Windows'):\n    pass"
p108
aS"print ('last modified: %s' % time.ctime(os.path.getmtime(file)))"
p109
aS"import os.path, time\nprint ('last modified: %s' % time.ctime(os.path.getmtime(file)))"
p110
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p111
aS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p112
aS'"\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p113
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    pass'
p114
aS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p115
aS'stat = os.stat(path_to_file)'
p116
aS"import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint ('last modified: %s' % time.ctime(mtime))"
p117
aS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p118
aS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime"
p119
aS"print ('last modified: %s' % time.ctime(mtime))"
p120
aS'import os.path, time'
p121
aS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p122
aS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p123
aS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p124
aS"import os.path, time\nprint ('last modified: %s' % time.ctime(os.path.getmtime(file)))\nprint ('created: %s' % time.ctime(os.path.getctime(file)))"
p125
aS"print ('created: %s' % time.ctime(os.path.getctime(file)))"
p126
aS'import os'
p127
aS'import platform'
p128
aS"d = modification_date('/var/log/syslog')"
p129
aS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p130
aS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p131
aS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p132
aS'print d\nprint repr(d)'
p133
aS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p134
aS"d = modification_date('/var/log/syslog')\nprint d\nprint repr(d)"
p135
aS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p136
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p137
aS"d = modification_date('/var/log/syslog')\nprint d"
p138
aS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass"
p139
aS'return stat.st_mtime'
p140
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p141
aS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p142
aS'import datetime'
p143
aS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p144
aS"(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint ('last modified: %s' % time.ctime(mtime))"
p145
aS'return datetime.datetime.fromtimestamp(t)'
p146
aS'print repr(d)'
p147
aS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p148
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p149
aS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p150
aS'import os, time'
p151
aS'print d'
p152
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p153
aS'import platform\n\ndef creation_date(path_to_file):\n    pass'
p154
aS'import datetime\n\ndef modification_date(filename):\n    pass'
p155
aS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p156
aS'import os\nimport datetime'
p157
aS'def modification_date(filename):\n    t = os.path.getmtime(filename)'
p158
aS'(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p159
aS'def creation_date(path_to_file):\n    pass'
p160
aS'return os.path.getctime(path_to_file)'
p161
aS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p162
aS'def modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p163
aS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p164
aS't = os.path.getmtime(filename)'
p165
aS'return stat.st_birthtime'
p166
aS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)"
p167
aS'import os\nimport datetime\n\ndef modification_date(filename):\n    pass'
p168
aS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)"
p169
aS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass"
p170
aS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p171
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p172
aS'import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p173
aS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p174
aS"print ('last modified: %s' % time.ctime(os.path.getmtime(file)))\nprint ('created: %s' % time.ctime(os.path.getctime(file)))"
p175
aS'import os\nimport platform'
p176
aS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p177
atp178
Rp179
sI6159900
g1
((lp180
S"f.write(('hi there' + os.linesep))\nf.close()"
p181
aS"f.write(('hi there' + os.linesep))"
p182
aS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
p183
aS"with open('somefile.txt', 'a') as the_file:\n    pass"
p184
aS'f.close()'
p185
aS"the_file.write('Hello\\n')"
p186
aS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p187
aS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p188
aS'os.linesep'
p189
aS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p190
aS"f = open('myfile', 'w')"
p191
aS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p192
aS"f = open('myfile', 'w')\nf.write('hi there\\n')"
p193
aS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p194
aS"with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
p195
aS"open('myfile', 'rb').read()"
p196
aS"os.linesep\nf = open('myfile', 'w')"
p197
aS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p198
aS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p199
aS"import os\nos.linesep\nf = open('myfile', 'w')"
p200
aS"f.close()\nopen('myfile', 'rb').read()"
p201
aS"from __future__ import print_function\nprint('hi there', file=f)"
p202
aS'import os'
p203
aS"f.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p204
aS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p205
aS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p206
aS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p207
aS"f.write('hi there\\n')\nf.close()"
p208
aS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p209
aS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p210
aS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p211
aS'from __future__ import print_function'
p212
aS"f.write('hi there\\n')"
p213
aS'import os\nos.linesep'
p214
aS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p215
atp216
Rp217
sI899103
g1
((lp218
S'print  >> thefile, item'
p219
aS'itemlist = pickle.load(infile)'
p220
aS'for item in thelist:\n    pass'
p221
aS"for item in thelist:\n    thefile.write(('%s\\n' % item))"
p222
aS'import pickle'
p223
aS"outfile.write('\\n'.join(itemlist))"
p224
aS'pickle.dump(itemlist, outfile)'
p225
aS"thefile.write(('%s\\n' % item))"
p226
aS'import pickle\npickle.dump(itemlist, outfile)'
p227
atp228
Rp229
sI3939361
g1
((lp230
S"string = 'ab1cd1ef'"
p231
aS"for char in b:\n    a = a.replace(char, '')\nprint a"
p232
aS'import re'
p233
aS"line = 'abc#@!?efg12;:?'\n''.join((c for c in line if (c not in '?:!/;')))"
p234
aS"line = line.translate(string.maketrans('', ''), '!@#$')"
p235
aS"import re\nline = re.sub('[!@#$]', '', line)"
p236
aS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    pass"
p237
aS'print a'
p238
aS"string = 'ab1cd1ef'\nstring.replace('1', '')"
p239
aS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p240
aS'import string'
p241
aS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)\nunicode_line = unicode_line.translate(translation_table)"
p242
aS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p243
aS"line = 'abc#@!?efg12;:?'"
p244
aS"string.replace('1', '')"
p245
aS"b = '!@#$'"
p246
aS"a = 'a!b@c#d$'"
p247
aS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)"
p248
aS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p249
aS"line = re.sub('[!@#$]', '', line)"
p250
aS"for char in b:\n    a = a.replace(char, '')"
p251
aS"''.join((c for c in line if (c not in '?:!/;')))"
p252
aS"b = '!@#$'\nfor char in b:\n    pass"
p253
aS"unicode_line = unicode_line.translate({ord(c): None for c in '!@#$'})"
p254
aS"import string\nline = line.translate(string.maketrans('', ''), '!@#$')"
p255
aS'unicode_line = unicode_line.translate(translation_table)'
p256
aS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p257
aS"a = 'a!b@c#d$'\nb = '!@#$'"
p258
aS"a = a.replace(char, '')"
p259
aS'for char in b:\n    pass'
p260
aS"line = line.translate(None, '!@#$')"
p261
atp262
Rp263
sI9001509
g1
((lp264
S'od[1]\nod[3]\nfor (k, v) in od.iteritems():\n    pass'
p265
aS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p266
aS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p267
aS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p268
aS'print k, v'
p269
aS'keylist.sort()\nfor key in keylist:\n    pass'
p270
aS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p271
aS'for key in sorted(mydict):\n    pass'
p272
aS'd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p273
aS'od[1]\nod[3]'
p274
aS'print (k, v)'
p275
aS'for key in keylist:\n    pass'
p276
aS'keylist.sort()'
p277
aS'keylist = mydict.keys()\nkeylist.sort()'
p278
aS"print ('%s: %s' % (key, mydict[key]))"
p279
aS'od = collections.OrderedDict(sorted(d.items()))\nod'
p280
aS'keylist = mydict.keys()'
p281
aS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p282
aS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p283
aS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p284
aS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p285
aS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p286
aS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p287
aS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p288
aS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }"
p289
aS'OrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p290
aS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))'
p291
aS'for (k, v) in od.items():\n    pass'
p292
aS'keylist = mydict.keys()\nkeylist.sort()\nfor key in keylist:\n    pass'
p293
aS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p294
aS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }\nfor key in sorted(mydict):\n    pass"
p295
aS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p296
aS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p297
aS'od[3]\nfor (k, v) in od.iteritems():\n    pass'
p298
aS'od[3]'
p299
aS'from collections import OrderedDict'
p300
aS'import collections'
p301
aS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p302
aS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p303
aS'od'
p304
aS'od[1]'
p305
aS'for (k, v) in od.iteritems():\n    pass'
p306
aS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p307
aS'od = collections.OrderedDict(sorted(d.items()))'
p308
atp309
Rp310
sI2990121
g1
((lp311
S'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p312
aS'from itertools import izip_longest'
p313
aS'for i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p314
aS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    pass'
p315
aS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p316
aS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p317
aS'return izip_longest(fillvalue=fillvalue, *args)'
p318
aS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p319
aS'"grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p320
aS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p321
aS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'
p322
aS'print i,'
p323
aS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p324
aS'args = ([iter(iterable)] * n)'
p325
aS'print i'
p326
aS'for i in xrange(0, 10, 2):\n    pass'
p327
aS'for (item1, item2) in grouper(2, l):\n    pass'
p328
aS'pass'
p329
aS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    pass'
p330
aS'for i in mylist[1::2]:\n    pass'
p331
aS'def grouper(n, iterable, fillvalue=None):\n    pass'
p332
aS'for i in mylist[::2]:\n    pass'
p333
aS'args = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p334
aS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p335
aS'for i in range(0, 10, 2):\n    pass'
p336
atp337
Rp338
sI26443308
g1
((lp339
S"'abcd}def}'.rfind('}')"
p340
atp341
Rp342
sI4174941
g1
((lp343
S'l.sort(key=(lambda x: x[2]))'
p344
aS'sorted_list = sorted(list_to_sort, key=itemgetter(2, 0, 1))'
p345
aS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p346
aS'sorted(l, key=(lambda x: x[2]))'
p347
aS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p348
aS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p349
aS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p350
aS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nl.sort(key=(lambda x: x[2]))"
p351
aS'from operator import itemgetter'
p352
aS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p353
aS'sorted(L, key=itemgetter(2))'
p354
atp355
Rp356
sI3207219
g1
((lp357
S"os.listdir('somedirectory')"
p358
aS'onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p359
aS'w = [4, 5, 6]\nq = (q + w)\nq'
p360
aS"import os\nos.listdir('somedirectory')"
p361
aS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)\nq'
p362
aS"print glob.glob('/home/adam/*.txt')"
p363
aS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p364
aS'q = [1, 2, 3]\nw = [4, 5, 6]'
p365
aS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p366
aS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p367
aS'break'
p368
aS'from os.path import isfile, join'
p369
aS'f = []'
p370
aS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p371
aS'q = (q + w)'
p372
aS'from os import listdir'
p373
aS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p374
aS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p375
aS'q = (q + w)\nq'
p376
aS"import glob\nprint glob.glob('/home/adam/*.txt')"
p377
aS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p378
aS'from os import walk\nf = []'
p379
aS'from os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p380
aS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)'
p381
aS'w = [4, 5, 6]'
p382
aS'f.extend(filenames)'
p383
aS'import os'
p384
aS'from os import walk'
p385
aS'q'
p386
aS'from os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p387
aS'w = [4, 5, 6]\nq = (q + w)'
p388
aS'q = [1, 2, 3]'
p389
aS'import glob'
p390
aS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p391
aS'from os import listdir\nfrom os.path import isfile, join'
p392
aS'for (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p393
atp394
Rp395
sI2972212
g1
((lp396
tp397
Rp398
sI53513
g1
((lp399
S"print 'List is empty'"
p400
aS"print 'the list is empty'"
p401
aS'if (len(li) == 0):\n    pass'
p402
aS'if (not a):\n    pass'
p403
atp404
Rp405
sI1514553
g1
((lp406
S'f = []\nfor i in range(30):\n    pass'
p407
aS'for i in range(30):\n    f.append(0)'
p408
aS'for i in range(30):\n    pass'
p409
aS"intarray = array('i')"
p410
aS'f = []\nfor i in range(30):\n    f.append(0)'
p411
aS'f = []'
p412
aS'from array import array'
p413
aS'variable = []'
p414
aS"from array import array\nintarray = array('i')"
p415
aS'f.append(0)'
p416
atp417
Rp418
sI2612802
g1
((lp419
S"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p420
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p421
aS't = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p422
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p423
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p424
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p425
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p426
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p427
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p428
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p429
aS'if (t == tuple):\n    is_tuple = True'
p430
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p431
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p432
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p433
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p434
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p435
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p436
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time"
p437
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p438
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p439
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p440
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p441
aS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p442
aS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p443
aS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p444
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p445
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p446
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p447
aS"print 'list append:', (time() - t)\nt = time()"
p448
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p449
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p450
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p451
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p452
aS'pass'
p453
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p454
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p455
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p456
aS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p457
aS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p458
aS'if is_tuple:\n    pass'
p459
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p460
aS"return obj\nif (__name__ == '__main__'):\n    import copy"
p461
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p462
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p463
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p464
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p465
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p466
aS'for i in xrange(num_times):\n    [i for i in L]'
p467
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p468
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p469
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p470
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p471
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p472
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p473
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p474
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p475
aS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p476
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p477
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p478
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p479
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p480
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p481
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p482
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p483
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p484
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p485
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p486
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p487
aS"print 'list(L):', (time() - t)"
p488
aS'Copy(L, use_deepcopy=False)'
p489
aS'obj[k] = Copy(obj[k], use_deepcopy)'
p490
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p491
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p492
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p493
aS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p494
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p495
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p496
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p497
aS'b = a[:]\nc = list(a)'
p498
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p499
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p500
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p501
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p502
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p503
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p504
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p505
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p506
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p507
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p508
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p509
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p510
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p511
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p512
aS'return obj'
p513
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p514
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p515
aS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p516
aS'def __repr__(self):\n    pass'
p517
aS'class old_class:\n    pass'
p518
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p519
aS't = time()\nfor i in xrange(num_times):\n    a = []'
p520
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p521
aS'b = a[:]'
p522
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p523
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p524
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p525
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p526
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p527
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p528
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p529
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p530
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p531
aS'class new_class(object):\n\n    def __init__(self):\n        pass'
p532
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p533
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p534
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p535
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p536
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p537
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p538
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p539
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p540
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p541
aS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p542
aS't = time()\nfor i in xrange(num_times):\n    Copy(L)'
p543
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p544
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p545
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p546
aS'for i in xrange(num_times):\n    copy.deepcopy(L)'
p547
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p548
aS'L[:]'
p549
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p550
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p551
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p552
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p553
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p554
aS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p555
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p556
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p557
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p558
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p559
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p560
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p561
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p562
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p563
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p564
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p565
aS'for i in xrange(num_times):\n    pass'
p566
aS'for y in L:\n    a.append(y)'
p567
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p568
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p569
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p570
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p571
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p572
aS'if (type(obj[x]) in dignore):\n    pass'
p573
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p574
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p575
aS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p576
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p577
aS'c = list(a)'
p578
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p579
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p580
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p581
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p582
aS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p583
aS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p584
aS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p585
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p586
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p587
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p588
aS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p589
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p590
aS'if is_tuple:\n    obj = tuple(obj)'
p591
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p592
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p593
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p594
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p595
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p596
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p597
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p598
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p599
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p600
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p601
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p602
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p603
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p604
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p605
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p606
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p607
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p608
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p609
aS'class Foo(object):\n    pass'
p610
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p611
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p612
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p613
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p614
aS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p615
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p616
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p617
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p618
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p619
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p620
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p621
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p622
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p623
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p624
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p625
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p626
aS'for i in xrange(num_times):\n    a = []\na.extend(L)'
p627
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p628
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p629
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p630
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p631
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p632
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p633
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p634
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p635
aS'import copy\nnew_list = copy.copy(old_list)'
p636
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p637
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p638
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p639
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p640
aS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p641
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p642
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p643
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p644
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p645
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p646
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p647
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p648
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p649
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p650
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p651
aS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p652
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p653
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p654
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p655
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p656
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p657
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p658
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p659
aS'for i in xrange(num_times):\n    copy.copy(L)'
p660
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p661
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p662
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p663
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p664
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p665
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p666
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p667
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p668
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p669
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p670
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p671
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p672
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p673
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p674
aS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p675
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p676
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p677
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p678
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p679
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p680
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p681
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p682
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p683
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p684
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p685
aS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p686
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p687
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p688
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p689
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p690
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p691
aS'new_list = old_list[:]'
p692
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p693
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p694
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p695
aS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p696
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p697
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p698
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p699
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p700
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p701
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p702
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p703
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p704
aS'if (t in (list, tuple)):\n    pass'
p705
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p706
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p707
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p708
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p709
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p710
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p711
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p712
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p713
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p714
aS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p715
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p716
aS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p717
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p718
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p719
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p720
aS'[i for i in L]'
p721
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p722
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p723
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p724
aS'for y in L:\n    pass'
p725
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p726
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p727
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p728
aS'is_tuple = True'
p729
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p730
aS'copy.deepcopy(L)'
p731
aS'num_times = 100000'
p732
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p733
aS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p734
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p735
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p736
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p737
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p738
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p739
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p740
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p741
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p742
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p743
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p744
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p745
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p746
aS'a.extend(L)'
p747
aS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p748
aS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p749
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p750
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p751
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p752
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p753
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p754
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p755
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p756
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p757
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p758
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p759
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p760
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p761
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p762
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p763
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p764
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p765
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p766
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p767
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p768
aS"print 'list expression(L):', (time() - t)\nt = time()"
p769
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p770
aS'new_list = copy.copy(old_list)'
p771
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p772
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p773
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p774
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p775
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p776
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p777
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p778
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p779
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p780
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p781
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p782
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p783
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p784
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p785
aS'for i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p786
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p787
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p788
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p789
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p790
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p791
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p792
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p793
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p794
aS'a = []'
p795
aS'for k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p796
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p797
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p798
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p799
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p800
aS'def __init__(self):\n    pass'
p801
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p802
aS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p803
aS't = time()\nfor i in xrange(num_times):\n    list(L)'
p804
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p805
aS'def Copy(obj, use_deepcopy=True):\n    pass'
p806
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p807
aS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p808
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p809
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p810
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p811
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p812
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p813
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p814
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p815
aS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p816
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p817
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p818
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p819
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p820
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p821
aS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p822
aS"print 'copy.deepcopy:', (time() - t)"
p823
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p824
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p825
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p826
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p827
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p828
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p829
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p830
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p831
aS'obj = deepcopy(obj)'
p832
aS'import copy\nnew_list = copy.deepcopy(old_list)'
p833
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p834
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p835
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p836
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p837
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p838
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p839
aS'a.extend((i for i in L))'
p840
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p841
aS'for i in xrange(num_times):\n    a = []'
p842
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    pass'
p843
aS'if (type(obj[k]) in dignore):\n    continue'
p844
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p845
aS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p846
aS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p847
aS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p848
aS'from copy import deepcopy'
p849
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p850
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p851
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p852
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p853
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p854
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p855
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p856
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p857
aS"print 'list slicing [:]:', (time() - t)\nt = time()"
p858
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p859
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p860
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p861
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p862
aS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p863
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p864
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p865
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p866
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p867
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p868
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p869
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p870
aS'obj = tuple(obj)'
p871
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p872
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p873
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p874
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p875
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p876
aS'continue'
p877
aS"a.append('baz')"
p878
aS'if (type(obj[x]) in dignore):\n    continue'
p879
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p880
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p881
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p882
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p883
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p884
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p885
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p886
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p887
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p888
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p889
aS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p890
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p891
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p892
aS'def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p893
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p894
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p895
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p896
aS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p897
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p898
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p899
aS'Copy(L)'
p900
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p901
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p902
aS"if (__name__ == '__main__'):\n    import copy"
p903
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p904
aS"a.append('baz')\nfoo.val = 5"
p905
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p906
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p907
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p908
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p909
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p910
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p911
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p912
aS'from time import time'
p913
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p914
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p915
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p916
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p917
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p918
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p919
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p920
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p921
aS"print 'generator expression extend:', (time() - t)"
p922
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p923
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p924
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p925
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p926
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p927
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p928
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p929
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p930
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p931
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p932
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p933
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p934
aS"self.blah = 'blah'"
p935
aS'from copy import deepcopy\n\n\nclass old_class:\n    pass'
p936
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p937
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p938
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p939
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p940
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p941
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p942
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p943
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p944
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p945
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p946
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p947
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p948
aS'list(L)'
p949
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p950
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p951
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p952
aS'for i in xrange(num_times):\n    Copy(L)'
p953
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p954
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p955
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p956
aS'def __repr__(self):\n    return str(self.val)'
p957
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p958
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p959
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p960
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p961
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p962
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p963
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p964
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p965
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p966
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p967
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p968
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p969
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p970
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p971
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p972
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p973
aS'obj = obj[:]'
p974
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p975
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p976
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p977
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p978
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p979
aS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p980
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p981
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p982
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p983
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p984
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p985
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p986
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p987
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p988
aS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p989
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p990
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p991
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p992
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p993
aS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p994
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p995
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p996
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p997
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p998
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p999
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1000
aS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1001
aS"a = ['foo', foo]"
p1002
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p1003
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1004
aS'from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        pass'
p1005
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1006
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1007
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1008
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p1009
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1010
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1011
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1012
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1013
aS"print 'Custom Copy:', (time() - t)\nt = time()"
p1014
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1015
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1016
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p1017
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1018
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1019
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1020
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1021
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1022
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1023
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1024
aS"print 'Custom Copy:', (time() - t)"
p1025
aS'class old_class:\n\n    def __init__(self):\n        pass'
p1026
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1027
aS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1028
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1029
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1030
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1031
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1032
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1033
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1034
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1035
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1036
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1037
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1038
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1039
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1040
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1041
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1042
aS'copy.copy(L)'
p1043
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1044
aS'class new_class(object):\n    pass'
p1045
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1046
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1047
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1048
aS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1049
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1050
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1051
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1052
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1053
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1054
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1055
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1056
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1057
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1058
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1059
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1060
aS't = time()\nfor i in xrange(num_times):\n    L[:]'
p1061
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1062
aS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass'
p1063
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1064
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1065
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1066
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1067
aS'def __init__(self, val):\n    pass'
p1068
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1069
aS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        pass'
p1070
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1071
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p1072
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1073
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p1074
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p1075
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1076
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1077
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p1078
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1079
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1080
aS"print 'list(L):', (time() - t)\nt = time()"
p1081
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1082
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1083
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1084
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1085
aS"print 'copy.deepcopy:', (time() - t)\nt = time()"
p1086
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1087
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1088
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1089
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1090
aS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1091
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1092
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1093
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1094
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1095
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p1096
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1097
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1098
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1099
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1100
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1101
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1102
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1103
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1104
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1105
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1106
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1107
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1108
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1109
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1110
aS"print 'list append:', (time() - t)"
p1111
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1112
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1113
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1114
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1115
aS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1116
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1117
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1118
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1119
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1120
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1121
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1122
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p1123
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1124
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1125
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1126
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1127
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1128
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1129
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1130
aS'e = copy.deepcopy(a)'
p1131
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1132
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1133
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1134
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p1135
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1136
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1137
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1138
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1139
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1140
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1141
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1142
aS'def __init__(self, val):\n    self.val = val'
p1143
aS't = time()'
p1144
aS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1145
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1146
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1147
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1148
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1149
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1150
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p1151
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1152
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1153
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1154
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1155
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1156
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1157
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1158
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1159
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1160
aS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p1161
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1162
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1163
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1164
aS'b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p1165
aS"foo = Foo(1)\na = ['foo', foo]"
p1166
aS'd = copy.copy(a)'
p1167
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1168
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1169
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1170
aS'for i in xrange(num_times):\n    L[:]'
p1171
aS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p1172
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1173
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1174
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1175
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1176
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1177
aS'from time import time\nnum_times = 100000'
p1178
aS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1179
aS'b = a[:]\nc = list(a)\nd = copy.copy(a)'
p1180
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1181
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1182
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1183
aS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1184
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p1185
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1186
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1187
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1188
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1189
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1190
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1191
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1192
aS'c = list(a)\nd = copy.copy(a)'
p1193
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1194
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1195
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1196
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1197
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1198
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1199
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1200
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1201
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1202
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1203
aS't = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)'
p1204
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1205
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1206
aS'a.append(y)'
p1207
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1208
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1209
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1210
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1211
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p1212
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1213
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1214
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1215
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1216
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1217
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1218
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1219
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1220
aS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1221
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1222
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1223
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1224
aS"a = ['foo', foo]\nb = a[:]\nc = list(a)"
p1225
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1226
aS"if (__name__ == '__main__'):\n    pass"
p1227
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1228
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1229
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1230
aS"print 'copy.copy:', (time() - t)\nt = time()"
p1231
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1232
aS'if (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1233
aS'for x in xrange(len(obj)):\n    pass'
p1234
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1235
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1236
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1237
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1238
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1239
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1240
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1241
aS"a = ['foo', foo]\nb = a[:]"
p1242
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1243
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1244
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1245
aS"def __init__(self):\n    self.blah = 'blah'"
p1246
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1247
aS't = type(obj)'
p1248
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1249
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1250
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1251
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1252
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1253
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1254
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1255
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1256
aS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p1257
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1258
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1259
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1260
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1261
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1262
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p1263
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1264
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1265
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1266
aS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1267
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1268
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1269
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1270
aS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1271
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1272
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1273
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1274
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1275
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1276
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1277
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1278
aS'foo = Foo(1)'
p1279
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1280
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1281
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1282
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1283
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1284
aS'obj[x] = Copy(obj[x], use_deepcopy)'
p1285
aS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1286
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p1287
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1288
aS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p1289
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1290
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1291
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p1292
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1293
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1294
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1295
aS'import copy'
p1296
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1297
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1298
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1299
aS'self.val = val'
p1300
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1301
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1302
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1303
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1304
aS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1305
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1306
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1307
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1308
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1309
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p1310
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1311
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1312
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1313
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p1314
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1315
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1316
aS't = time()\nfor i in xrange(num_times):\n    [i for i in L]'
p1317
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1318
aS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p1319
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1320
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1321
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1322
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1323
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1324
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1325
aS'd = copy.copy(a)\ne = copy.deepcopy(a)'
p1326
aS"e = copy.deepcopy(a)\na.append('baz')"
p1327
aS'class Foo(object):\n\n    def __init__(self, val):\n        pass'
p1328
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1329
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1330
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1331
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1332
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1333
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1334
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1335
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1336
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1337
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1338
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1339
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1340
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1341
aS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p1342
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1343
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1344
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1345
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1346
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1347
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1348
aS'dignore = {str: None, unicode: None, int: None, type(None): None, }'
p1349
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1350
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1351
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1352
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1353
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1354
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1355
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1356
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1357
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1358
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1359
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1360
aS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p1361
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p1362
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1363
aS't = time()\nfor i in xrange(num_times):\n    copy.copy(L)'
p1364
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1365
aS'obj = obj.copy()'
p1366
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1367
aS'if (type(obj[k]) in dignore):\n    pass'
p1368
aS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1369
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p1370
aS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1371
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1372
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1373
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1374
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p1375
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1376
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1377
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1378
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1379
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1380
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1381
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1382
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1383
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1384
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p1385
aS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1386
aS"print ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1387
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1388
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1389
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1390
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1391
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1392
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1393
aS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p1394
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1395
aS"print 'copy.copy:', (time() - t)"
p1396
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1397
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1398
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1399
aS'for k in obj:\n    pass'
p1400
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1401
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1402
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1403
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1404
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1405
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1406
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1407
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1408
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1409
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1410
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1411
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1412
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1413
aS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1414
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1415
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1416
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1417
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1418
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1419
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1420
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1421
aS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1422
aS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p1423
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1424
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1425
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1426
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1427
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1428
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1429
aS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)'
p1430
aS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1431
aS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p1432
aS'c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p1433
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1434
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1435
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1436
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1437
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1438
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1439
aS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p1440
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1441
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1442
aS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1443
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1444
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1445
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p1446
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1447
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1448
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time"
p1449
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1450
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1451
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1452
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1453
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1454
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1455
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1456
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1457
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p1458
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1459
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1460
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1461
aS"foo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1462
aS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1463
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1464
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1465
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1466
aS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p1467
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1468
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1469
aS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1470
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1471
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1472
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1473
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1474
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1475
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1476
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1477
aS"print 'list slicing [:]:', (time() - t)"
p1478
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1479
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1480
aS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1481
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1482
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1483
aS'import copy\n\n\nclass Foo(object):\n    pass'
p1484
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1485
aS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1486
aS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1487
aS't = time()\nfor i in xrange(num_times):\n    pass'
p1488
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1489
aS'if (t == tuple):\n    pass'
p1490
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1491
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1492
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1493
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1494
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1495
aS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1496
aS'obj = list(obj)'
p1497
aS'for i in xrange(num_times):\n    list(L)'
p1498
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1499
aS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1500
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1501
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1502
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1503
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1504
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1505
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1506
aS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1507
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1508
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1509
aS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1510
aS"print 'list extend:', (time() - t)\nt = time()"
p1511
aS"a.extend(L)\nprint 'list extend:', (time() - t)"
p1512
aS'new_list = copy.deepcopy(old_list)'
p1513
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1514
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1515
aS'return str(self.val)'
p1516
aS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1517
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1518
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1519
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1520
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1521
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1522
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1523
aS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1524
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1525
aS'foo.val = 5'
p1526
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1527
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1528
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1529
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1530
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1531
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1532
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1533
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1534
aS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1535
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1536
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1537
aS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1538
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1539
aS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1540
aS"for i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1541
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1542
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1543
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1544
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1545
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1546
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1547
aS"print 'list expression(L):', (time() - t)"
p1548
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1549
aS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1550
aS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1551
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1552
aS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1553
aS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1554
aS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1555
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1556
aS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1557
aS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1558
aS'for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p1559
aS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p1560
aS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1561
aS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1562
aS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p1563
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1564
aS"print 'list extend:', (time() - t)"
p1565
aS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1566
aS'new_list = list(old_list)'
p1567
aS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1568
aS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p1569
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1570
aS"a.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1571
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1572
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1573
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1574
aS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1575
aS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p1576
aS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1577
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1578
aS"a.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1579
aS'is_tuple = False'
p1580
aS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1581
aS"return obj\nif (__name__ == '__main__'):\n    pass"
p1582
aS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1583
aS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1584
aS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1585
aS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p1586
aS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1587
aS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1588
aS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p1589
aS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1590
aS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1591
aS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1592
aS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1593
aS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1594
aS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1595
atp1596
Rp1597
sI402504
g1
((lp1598
S'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p1599
aS'(type(i) is float)'
p1600
aS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p1601
aS'type(i)\n(type(i) is long)\ni = 123.456'
p1602
aS'(type(i) is int)\ni = 123456789L\ntype(i)'
p1603
aS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p1604
aS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p1605
aS"v = 'hi'"
p1606
aS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p1607
aS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p1608
aS'(type(i) is long)\ni = 123.456'
p1609
aS'i = 123'
p1610
aS'v = 100000000000000'
p1611
aS'v = 10\ntype(v)'
p1612
aS'i = 123.456\ntype(i)'
p1613
aS'i = 123456789L\ntype(i)'
p1614
aS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p1615
aS'i = 123\ntype(i)'
p1616
aS'i = 123456789L'
p1617
aS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p1618
aS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L'
p1619
aS'v = 100000000000000\ntype(v)'
p1620
aS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p1621
aS'(type(i) is int)\ni = 123456789L'
p1622
aS'(type(i) is long)\ni = 123.456\ntype(i)'
p1623
aS'type(i)\n(type(i) is long)'
p1624
aS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p1625
aS'type(i)\n(type(i) is int)'
p1626
aS'i = 123456789L\ntype(i)\n(type(i) is long)'
p1627
aS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p1628
aS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p1629
aS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p1630
aS'type(v)'
p1631
aS'i = 123.456'
p1632
aS'print type(variable_name)'
p1633
aS'v = (-10)\ntype(v)'
p1634
aS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p1635
aS'type(i)\n(type(i) is int)\ni = 123456789L'
p1636
aS'type(i)'
p1637
aS'i = 123.456\ntype(i)\n(type(i) is float)'
p1638
aS'v = (-10)'
p1639
aS'(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p1640
aS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p1641
aS'type(i)\n(type(i) is float)'
p1642
aS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p1643
aS'(type(i) is int)'
p1644
aS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p1645
aS'(type(i) is long)'
p1646
aS'v = 10'
p1647
aS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p1648
aS'i = 123\ntype(i)\n(type(i) is int)'
p1649
aS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p1650
aS"v = 'hi'\ntype(v)"
p1651
atp1652
Rp1653
sI275018
g1
((lp1654
S"'test string \\n\\n'.rstrip('\\n')"
p1655
aS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()"
p1656
aS'text.splitlines()'
p1657
aS"'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p1658
aS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()\ns.lstrip()"
p1659
aS"s = ' \\n  abc   def   '"
p1660
aS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'"
p1661
aS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'\ntext.splitlines()"
p1662
aS"'Mac EOL\\r'.rstrip('\\r\\n')"
p1663
aS's.strip()\ns.rstrip()'
p1664
aS"'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p1665
aS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p1666
aS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p1667
aS's.strip()'
p1668
aS's.lstrip()'
p1669
aS's.strip()\ns.rstrip()\ns.lstrip()'
p1670
aS"s = ' \\n  abc   def   '\ns.strip()"
p1671
aS's.rstrip()'
p1672
aS"'Hello\\n\\n\\n'.rstrip('\\n')"
p1673
aS"'Unix EOL\\n'.rstrip('\\r\\n')"
p1674
aS's.rstrip()\ns.lstrip()'
p1675
aS"'test string\\n'.rstrip()"
p1676
atp1677
Rp1678
sI276052
g1
((lp1679
S'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p1680
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p1681
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p1682
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p1683
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p1684
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p1685
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p1686
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p1687
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p1688
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1689
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p1690
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p1691
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p1692
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1693
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p1694
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p1695
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1696
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p1697
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p1698
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p1699
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p1700
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p1701
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1702
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p1703
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p1704
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p1705
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p1706
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1707
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p1708
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p1709
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p1710
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1711
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p1712
aS'import win32com.client\nfrom ctypes import *'
p1713
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p1714
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p1715
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p1716
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p1717
aS'import psutil'
p1718
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p1719
aS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p1720
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p1721
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p1722
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p1723
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1724
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1725
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1726
aS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p1727
aS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())'
p1728
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p1729
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1730
aS'class process_stats:\n    pass'
p1731
aS'return x\n\n\nclass process_stats:\n    pass'
p1732
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1733
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p1734
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p1735
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p1736
aS'import psutil\nprint psutil.cpu_percent()'
p1737
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p1738
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p1739
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p1740
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1741
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p1742
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p1743
aS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p1744
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p1745
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1746
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p1747
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p1748
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p1749
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p1750
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p1751
aS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p1752
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p1753
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p1754
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p1755
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p1756
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1757
aS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        pass"
p1758
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p1759
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p1760
aS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p1761
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p1762
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p1763
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p1764
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1765
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p1766
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p1767
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p1768
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p1769
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p1770
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p1771
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p1772
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p1773
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p1774
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p1775
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p1776
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1777
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p1778
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p1779
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p1780
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p1781
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p1782
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p1783
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p1784
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p1785
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1786
aS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p1787
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p1788
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p1789
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p1790
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p1791
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p1792
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p1793
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1794
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p1795
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p1796
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p1797
aS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p1798
aS'if found_flag:\n    pass'
p1799
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p1800
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1801
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p1802
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p1803
aS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p1804
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p1805
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p1806
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p1807
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p1808
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p1809
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list"
p1810
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p1811
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p1812
aS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p1813
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p1814
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p1815
aS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p1816
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p1817
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p1818
aS'return proc_results_list\n\ndef get_sys_stats():\n    pass'
p1819
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p1820
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p1821
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p1822
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p1823
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1824
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p1825
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1826
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p1827
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p1828
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p1829
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1830
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p1831
aS'import pythoncom\nimport pywintypes'
p1832
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p1833
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p1834
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p1835
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p1836
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p1837
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p1838
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p1839
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1840
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1841
aS'import os\nthis_pid = os.getpid()'
p1842
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1843
aS'import os\nimport psutil\npid = os.getpid()'
p1844
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1845
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p1846
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p1847
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p1848
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p1849
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p1850
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p1851
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1852
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p1853
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p1854
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p1855
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p1856
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p1857
aS"for attribute in self.supported_types[counter_type]:\n    eval_str = ('objItem.%s' % attribute)"
p1858
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1859
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p1860
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p1861
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p1862
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p1863
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p1864
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p1865
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p1866
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p1867
aS'def winmem():\n    x = MEMORYSTATUS()'
p1868
aS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p1869
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p1870
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p1871
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p1872
aS'break'
p1873
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p1874
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p1875
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p1876
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p1877
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1878
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p1879
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p1880
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p1881
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p1882
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1883
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p1884
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p1885
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p1886
aS'x = winmem()'
p1887
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p1888
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p1889
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1890
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p1891
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p1892
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p1893
aS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p1894
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p1895
aS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            eval_str = ('objItem.%s' % attribute)"
p1896
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p1897
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p1898
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p1899
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p1900
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p1901
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p1902
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p1903
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1904
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p1905
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p1906
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p1907
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1908
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p1909
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p1910
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p1911
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p1912
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p1913
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p1914
aS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p1915
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p1916
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p1917
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1918
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p1919
aS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1920
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p1921
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p1922
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p1923
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p1924
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p1925
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p1926
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p1927
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p1928
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p1929
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1930
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p1931
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p1932
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1933
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p1934
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p1935
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p1936
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1937
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p1938
aS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p1939
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p1940
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1941
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p1942
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p1943
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p1944
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p1945
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1946
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p1947
aS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p1948
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p1949
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1950
aS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p1951
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p1952
aS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p1953
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p1954
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p1955
aS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p1956
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p1957
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p1958
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p1959
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p1960
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p1961
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p1962
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p1963
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1964
aS'pythoncom.CoInitialize()\nx = winmem()'
p1965
aS'if (proc_name.lower() in obj_name.lower()):\n    pass'
p1966
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p1967
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p1968
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p1969
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p1970
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p1971
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p1972
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p1973
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p1974
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p1975
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p1976
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p1977
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p1978
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1979
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p1980
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p1981
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p1982
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p1983
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p1984
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p1985
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p1986
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p1987
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p1988
aS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p1989
aS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p1990
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p1991
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p1992
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p1993
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p1994
aS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p1995
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p1996
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p1997
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p1998
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p1999
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2000
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2001
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2002
aS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p2003
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2004
aS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2005
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2006
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2007
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2008
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2009
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2010
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2011
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2012
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p2013
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'"
p2014
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2015
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p2016
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p2017
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2018
aS'if (len(colItems) > 0):\n    pass'
p2019
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2020
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2021
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2022
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2023
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2024
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2025
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2026
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2027
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2028
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p2029
aS'__revision__ = 3'
p2030
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2031
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2032
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p2033
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2034
aS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p2035
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2036
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2037
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2038
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2039
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2040
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2041
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2042
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2043
aS'colItems = objSWbemServices.ExecQuery(query_str)'
p2044
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2045
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2046
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2047
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2048
aS'memoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p2049
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2050
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2051
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2052
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p2053
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2054
aS'this_proc_dict[attribute] = eval(eval_str)'
p2055
aS'import os'
p2056
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2057
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2058
aS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p2059
aS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p2060
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2061
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()'
p2062
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p2063
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2064
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2065
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list"
p2066
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2067
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2068
aS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2069
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2070
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2071
aS'for counter_type in perf_object_list:\n    pass'
p2072
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2073
aS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p2074
aS'def winmem():\n    pass'
p2075
aS'import datetime'
p2076
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2077
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2078
aS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2079
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2080
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2081
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2082
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2083
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2084
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2085
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2086
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2087
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2088
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2089
aS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2090
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p2091
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2092
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2093
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2094
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2095
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2096
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2097
aS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2098
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2099
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2100
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2101
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2102
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2103
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2104
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2105
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2106
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2107
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2108
aS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p2109
aS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2110
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p2111
aS'def get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2112
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2113
aS'import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p2114
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2115
aS'perf_object_list = self.supported_types.keys()'
p2116
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2117
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2118
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2119
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2120
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2121
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p2122
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2123
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2124
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2125
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2126
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2127
aS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2128
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2129
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2130
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2131
aS'print result_dict'
p2132
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p2133
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2134
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2135
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2136
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2137
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2138
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2139
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2140
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2141
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2142
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2143
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2144
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2145
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2146
aS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p2147
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2148
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2149
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2150
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2151
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2152
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2153
aS'pid = os.getpid()\npy = psutil.Process(pid)'
p2154
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2155
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p2156
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2157
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2158
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2159
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p2160
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p2161
aS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2162
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2163
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2164
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p2165
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2166
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2167
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2168
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2169
aS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p2170
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p2171
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2172
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2173
aS"'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2174
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2175
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2176
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2177
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2178
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2179
aS'break\nif found_flag:\n    pass'
p2180
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2181
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2182
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2183
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2184
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2185
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2186
aS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p2187
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2188
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2189
aS'proc_results_list.append(this_proc_dict)'
p2190
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2191
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p2192
aS'proc_results = stats_processor.get_stats()'
p2193
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p2194
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2195
aS'from ctypes import *\nfrom ctypes.wintypes import *'
p2196
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2197
aS'print this_proc_results'
p2198
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2199
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2200
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p2201
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2202
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]'
p2203
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2204
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2205
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p2206
aS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p2207
aS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p2208
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2209
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2210
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2211
aS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p2212
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2213
aS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p2214
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2215
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2216
aS'import pywintypes'
p2217
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2218
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2219
aS'sys_dict = get_sys_stats()'
p2220
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2221
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2222
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2223
aS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())\nprint(psutil.virtual_memory())'
p2224
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2225
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2226
aS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2227
aS'if (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2228
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2229
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2230
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p2231
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p2232
aS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p2233
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p2234
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2235
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2236
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2237
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2238
aS'from ctypes.wintypes import *\nimport pythoncom'
p2239
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2240
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2241
aS'import psutil\npid = os.getpid()'
p2242
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2243
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2244
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2245
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2246
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p2247
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2248
aS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p2249
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2250
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2251
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2252
aS"eval_str = ('objItem.%s' % attribute)"
p2253
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2254
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p2255
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2256
aS'pid = os.getpid()'
p2257
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p2258
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2259
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2260
aS'continue'
p2261
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2262
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2263
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2264
aS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2265
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2266
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p2267
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2268
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2269
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2270
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2271
aS'import pythoncom'
p2272
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2273
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2274
aS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2275
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2276
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2277
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2278
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2279
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2280
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2281
aS'def get_pid_stats(self, pid):\n    pass'
p2282
aS'import win32com.client'
p2283
aS'self.filter_list = filter_list'
p2284
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2285
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2286
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2287
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2288
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2289
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2290
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2291
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p2292
aS'pythoncom.CoInitialize()'
p2293
aS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2294
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2295
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p2296
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2297
aS'import pythoncom\nimport pywintypes\nimport datetime'
p2298
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2299
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2300
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p2301
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2302
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2303
aS'x = MEMORYSTATUS()'
p2304
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2305
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2306
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2307
aS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2308
aS"'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p2309
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2310
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2311
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2312
aS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p2313
aS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p2314
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2315
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2316
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2317
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2318
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2319
aS"pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p2320
aS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p2321
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2322
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2323
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2324
aS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p2325
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2326
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2327
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2328
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p2329
aS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p2330
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2331
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2332
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p2333
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2334
aS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p2335
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2336
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2337
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2338
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2339
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p2340
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2341
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2342
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2343
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2344
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2345
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2346
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2347
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2348
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2349
aS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p2350
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2351
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2352
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2353
aS'if (not self.process_name_list):\n    pass'
p2354
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2355
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p2356
aS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2357
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2358
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2359
aS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2360
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2361
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2362
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2363
aS"import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p2364
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2365
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list"
p2366
aS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2367
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2368
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2369
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2370
aS'from ctypes import *'
p2371
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2372
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p2373
aS'this_pid = os.getpid()'
p2374
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2375
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2376
aS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p2377
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2378
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2379
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2380
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2381
aS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p2382
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2383
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p2384
aS'import os\nimport psutil'
p2385
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2386
aS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p2387
aS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2388
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2389
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2390
aS'return x'
p2391
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2392
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p2393
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p2394
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2395
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2396
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2397
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p2398
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2399
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2400
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p2401
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p2402
aS'print psutil.cpu_percent()\nprint psutil.virtual_memory()'
p2403
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2404
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p2405
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"'
p2406
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2407
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2408
aS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p2409
aS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p2410
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2411
aS'__revision__ = 3\nimport win32com.client'
p2412
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2413
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2414
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2415
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p2416
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2417
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p2418
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p2419
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2420
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2421
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2422
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2423
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2424
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2425
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2426
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2427
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2428
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2429
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2430
aS'if (len(colItems) > 0):\n    for objItem in colItems:\n        found_flag = False'
p2431
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2432
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p2433
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client'
p2434
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2435
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2436
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2437
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2438
aS"return sys_dict\nif (__name__ == '__main__'):\n    pass"
p2439
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2440
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2441
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2442
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2443
aS'from __future__ import print_function'
p2444
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2445
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2446
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2447
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p2448
aS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p2449
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2450
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2451
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2452
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2453
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2454
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p2455
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2456
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2457
aS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p2458
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p2459
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p2460
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2461
aS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p2462
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2463
aS"print 'this proc results:'\nprint this_proc_results"
p2464
aS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p2465
aS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2466
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2467
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2468
aS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2469
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2470
aS'from ctypes.wintypes import *'
p2471
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2472
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p2473
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2474
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2475
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2476
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2477
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2478
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2479
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2480
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2481
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2482
aS'proc_results_list = []'
p2483
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2484
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2485
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True'
p2486
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p2487
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2488
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2489
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p2490
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2491
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p2492
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2493
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p2494
aS'if (not self.process_name_list):\n    found_flag = True'
p2495
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2496
aS'print psutil.virtual_memory()'
p2497
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2498
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p2499
aS"memoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p2500
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2501
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p2502
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2503
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p2504
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2505
aS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2506
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p2507
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p2508
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2509
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2510
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2511
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2512
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2513
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2514
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2515
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2516
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2517
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2518
aS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2519
aS'if (not self.perf_object_list):\n    pass'
p2520
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2521
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2522
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2523
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2524
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2525
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2526
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2527
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p2528
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2529
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2530
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2531
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2532
aS'if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p2533
aS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p2534
aS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p2535
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p2536
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2537
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2538
aS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p2539
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2540
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2541
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p2542
aS'return proc_results_list'
p2543
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2544
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2545
aS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2546
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2547
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2548
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2549
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2550
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2551
aS'for result_dict in proc_results:\n    pass'
p2552
aS'for proc_name in self.process_name_list:\n    pass'
p2553
aS"for counter_type in perf_object_list:\n    strComputer = '.'"
p2554
aS"strComputer = '.'"
p2555
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2556
aS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p2557
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2558
aS"print ('memory use:', memoryUse)"
p2559
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2560
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2561
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2562
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2563
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2564
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2565
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2566
aS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        pass"
p2567
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2568
aS'pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p2569
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2570
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2571
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2572
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2573
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p2574
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2575
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p2576
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2577
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2578
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2579
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2580
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2581
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p2582
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2583
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2584
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2585
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2586
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2587
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p2588
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2589
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2590
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p2591
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2592
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2593
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2594
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p2595
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2596
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2597
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2598
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2599
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2600
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p2601
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p2602
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2603
aS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p2604
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2605
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2606
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2607
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2608
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2609
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p2610
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p2611
aS'import pywintypes\nimport datetime'
p2612
aS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p2613
aS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass'
p2614
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2615
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2616
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2617
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2618
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2619
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2620
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2621
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2622
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2623
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2624
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2625
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p2626
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2627
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2628
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2629
aS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p2630
aS'proc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2631
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2632
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2633
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2634
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2635
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p2636
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2637
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p2638
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p2639
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2640
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p2641
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2642
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2643
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2644
aS'this_proc_results = stats_processor.get_pid_stats(this_pid)'
p2645
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2646
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2647
aS'obj_name = objItem.Name'
p2648
aS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2649
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2650
aS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p2651
aS"_fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p2652
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2653
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2654
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p2655
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2656
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2657
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p2658
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2659
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2660
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2661
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p2662
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2663
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2664
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2665
aS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            pass"
p2666
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2667
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2668
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2669
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2670
aS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p2671
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p2672
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    pass'
p2673
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2674
aS'def get_sys_stats():\n    pass'
p2675
aS"if (__name__ == '__main__'):\n    pass"
p2676
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2677
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2678
aS'import psutil\nprint psutil.cpu_percent()\nprint psutil.virtual_memory()'
p2679
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2680
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2681
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2682
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2683
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2684
aS'this_proc_dict = {}'
p2685
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2686
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2687
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p2688
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2689
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2690
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2691
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p2692
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2693
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2694
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2695
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2696
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2697
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2698
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2699
aS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p2700
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p2701
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2702
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2703
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2704
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2705
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2706
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2707
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2708
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p2709
aS'py = psutil.Process(pid)'
p2710
aS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2711
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2712
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2713
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2714
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2715
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2716
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2717
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2718
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2719
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2720
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2721
aS'for proc_name in self.process_name_list:\n    obj_name = objItem.Name'
p2722
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2723
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p2724
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2725
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2726
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p2727
aS'return this_proc_dict'
p2728
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2729
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p2730
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p2731
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2732
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2733
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2734
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2735
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p2736
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2737
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2738
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2739
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2740
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2741
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p2742
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2743
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2744
aS'pythoncom.CoInitialize()\nproc_results_list = []'
p2745
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2746
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2747
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2748
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2749
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2750
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2751
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p2752
aS'return this_proc_dict\n\ndef get_stats(self):\n    pass'
p2753
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2754
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2755
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p2756
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2757
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p2758
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p2759
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2760
aS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p2761
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2762
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2763
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2764
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2765
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2766
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2767
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2768
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p2769
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2770
aS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os'
p2771
aS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2772
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2773
aS'this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p2774
aS'windll.kernel32.GlobalMemoryStatus(byref(x))'
p2775
aS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2776
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2777
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2778
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2779
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2780
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2781
aS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p2782
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2783
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2784
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2785
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2786
aS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2787
aS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2788
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p2789
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p2790
aS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2791
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2792
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p2793
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2794
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2795
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2796
aS'found_flag = False'
p2797
aS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p2798
aS"' Returns a dictionary of the system stats'"
p2799
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()"
p2800
aS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p2801
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2802
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p2803
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2804
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p2805
aS'self.perf_object_list = perf_object_list'
p2806
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2807
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2808
aS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p2809
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p2810
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2811
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p2812
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2813
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p2814
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2815
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p2816
aS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2817
aS'return sys_dict'
p2818
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2819
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2820
aS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p2821
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p2822
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2823
aS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p2824
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2825
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p2826
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2827
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p2828
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2829
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2830
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p2831
aS'from __future__ import print_function\nimport psutil'
p2832
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2833
aS'py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p2834
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p2835
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p2836
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p2837
aS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p2838
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2839
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2840
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p2841
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p2842
aS'"process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p2843
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2844
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2845
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2846
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p2847
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2848
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p2849
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2850
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p2851
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2852
aS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2853
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2854
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2855
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2856
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2857
aS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p2858
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2859
aS'for attribute in self.supported_types[counter_type]:\n    pass'
p2860
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p2861
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2862
aS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p2863
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2864
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2865
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2866
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p2867
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2868
aS"print 'this proc results:'"
p2869
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2870
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2871
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2872
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2873
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2874
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2875
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2876
aS'for objItem in colItems:\n    pass'
p2877
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p2878
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p2879
aS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2880
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2881
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p2882
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2883
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2884
aS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p2885
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p2886
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2887
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2888
aS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2889
aS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2890
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2891
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2892
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2893
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2894
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p2895
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p2896
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2897
aS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p2898
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2899
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2900
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p2901
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2902
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3'
p2903
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p2904
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2905
aS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2906
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2907
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2908
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p2909
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p2910
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2911
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p2912
aS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p2913
aS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2914
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2915
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p2916
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p2917
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2918
aS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p2919
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2920
aS'break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p2921
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2922
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p2923
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2924
aS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p2925
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p2926
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2927
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2928
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p2929
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2930
aS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2931
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p2932
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2933
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2934
aS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p2935
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p2936
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p2937
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p2938
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2939
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p2940
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2941
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2942
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p2943
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2944
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2945
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p2946
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2947
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p2948
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2949
aS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p2950
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2951
aS'class MEMORYSTATUS(Structure):\n    pass'
p2952
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p2953
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p2954
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p2955
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p2956
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p2957
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2958
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2959
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p2960
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p2961
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p2962
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p2963
aS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p2964
aS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p2965
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p2966
aS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p2967
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2968
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p2969
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2970
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2971
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p2972
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2973
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2974
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2975
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p2976
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p2977
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p2978
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p2979
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p2980
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p2981
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p2982
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p2983
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p2984
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p2985
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p2986
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p2987
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p2988
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p2989
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2990
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p2991
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p2992
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p2993
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p2994
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p2995
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p2996
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p2997
aS'def get_stats(self):\n    pass'
p2998
aS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p2999
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3000
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3001
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3002
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3003
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3004
aS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3005
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3006
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p3007
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3008
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3009
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p3010
aS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3011
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3012
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p3013
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3014
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3015
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3016
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p3017
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3018
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3019
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p3020
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3021
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3022
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3023
aS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3024
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3025
aS'break\nreturn this_proc_dict'
p3026
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3027
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3028
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3029
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3030
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3031
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3032
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p3033
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3034
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3035
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3036
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3037
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p3038
aS'for objItem in colItems:\n    found_flag = False'
p3039
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3040
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3041
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3042
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3043
aS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3044
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3045
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3046
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3047
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p3048
aS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3049
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p3050
aS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3051
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3052
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3053
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3054
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3055
aS'for result_dict in proc_results:\n    print result_dict\nimport os'
p3056
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3057
aS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3058
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3059
aS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3060
aS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    pass"
p3061
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3062
aS'print psutil.cpu_percent()'
p3063
aS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3064
aS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3065
aS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3066
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3067
aS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3068
aS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3069
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3070
aS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3071
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3072
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3073
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3074
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3075
aS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3076
aS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3077
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3078
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3079
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3080
aS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3081
aS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3082
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3083
aS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3084
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p3085
aS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3086
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3087
aS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p3088
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p3089
aS'found_flag = True'
p3090
aS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3091
aS'self.process_name_list = process_name_list'
p3092
aS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3093
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p3094
aS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3095
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p3096
aS"import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p3097
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3098
aS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3099
aS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3100
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3101
aS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3102
aS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3103
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3104
aS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3105
aS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3106
aS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p3107
aS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3108
aS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3109
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3110
aS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3111
aS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p3112
aS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3113
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    pass'
p3114
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3115
aS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3116
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3117
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3118
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3119
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3120
aS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3121
aS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3122
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p3123
aS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3124
aS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3125
aS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3126
aS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3127
aS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3128
aS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3129
aS"py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p3130
aS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3131
aS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p3132
aS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p3133
atp3134
Rp3135
sI5137497
g1
((lp3136
S"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p3137
aS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3138
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')"
p3139
aS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3140
aS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3141
aS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3142
aS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3143
aS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p3144
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p3145
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3146
aS"print (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3147
aS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3148
aS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3149
aS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3150
aS'print os.path.dirname(full_path)'
p3151
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3152
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p3153
aS"print 'This file directory and name'"
p3154
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3155
aS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3156
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3157
aS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p3158
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3159
aS"print 'Path at terminal when executing this file'"
p3160
aS"print 'This file path, relative to os.getcwd()'"
p3161
aS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3162
aS"print (__file__ + '\\n')"
p3163
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p3164
aS'import os'
p3165
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3166
aS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3167
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p3168
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3169
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p3170
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p3171
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p3172
aS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3173
aS'dir_path = os.path.dirname(os.path.realpath(__file__))'
p3174
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p3175
aS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3176
aS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3177
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p3178
aS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p3179
aS"print (os.getcwd() + '\\n')"
p3180
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p3181
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3182
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p3183
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')"
p3184
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3185
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p3186
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p3187
aS"print 'This file directory only'\nprint os.path.dirname(full_path)"
p3188
aS"print (full_path + '\\n')\nprint 'This file directory and name'"
p3189
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p3190
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p3191
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3192
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p3193
aS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p3194
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p3195
aS"import os\nprint 'Path at terminal when executing this file'"
p3196
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p3197
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3198
aS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3199
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3200
aS'cwd = os.getcwd()'
p3201
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p3202
aS"print (((path + ' --> ') + filename) + '\\n')"
p3203
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3204
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p3205
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p3206
aS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3207
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p3208
aS"print 'This file full path (following symlinks)'"
p3209
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3210
aS'(path, filename) = os.path.split(full_path)'
p3211
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3212
aS"print (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3213
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p3214
aS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3215
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3216
aS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p3217
aS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3218
aS'full_path = os.path.realpath(__file__)'
p3219
aS'import os\ncwd = os.getcwd()'
p3220
aS"print (full_path + '\\n')"
p3221
aS"print 'This file directory only'"
p3222
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p3223
aS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3224
aS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p3225
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p3226
aS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p3227
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p3228
aS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p3229
aS'import os\ndir_path = os.path.dirname(os.path.realpath(__file__))'
p3230
aS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p3231
atp3232
Rp3233
sI930397
g1
((lp3234
S"alist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p3235
aS'alist = []\nalist[(-1)]\nalist[(-1):]'
p3236
aS'some_list[(-2)] = 3'
p3237
aS'alist[(-1)]\nalist[(-1):]'
p3238
aS'alist[(-1):]'
p3239
aS'alist = []\nalist[(-1)]'
p3240
aS"astr = ''"
p3241
aS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p3242
aS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''"
p3243
aS'some_list = [1, 2, 3]'
p3244
aS'astr[(-1)]\nastr[(-1):]'
p3245
aS"astr = ''\nastr[(-1)]\nastr[(-1):]"
p3246
aS'alist = []'
p3247
aS'astr[(-1)]'
p3248
aS"alist[(-1):]\nastr = ''\nastr[(-1)]"
p3249
aS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p3250
aS'alist[(-1)]'
p3251
aS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5'
p3252
aS'some_list'
p3253
aS'alist.pop()'
p3254
aS"alist[(-1)]\nalist[(-1):]\nastr = ''"
p3255
aS'some_list[(-1)] = 5'
p3256
aS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p3257
aS"alist[(-1):]\nastr = ''"
p3258
aS'some_list[(-1)] = 5\nsome_list[(-2)] = 3'
p3259
aS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p3260
aS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3'
p3261
aS'some_list[(-2)] = 3\nsome_list'
p3262
aS'some_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p3263
aS"astr = ''\nastr[(-1)]"
p3264
aS'astr[(-1):]'
p3265
aS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p3266
atp3267
Rp3268
sI961632
g1
((lp3269
S"str(10)\nint('10')"
p3270
aS'str(a)'
p3271
aS'a.__str__()'
p3272
aS'str(10)'
p3273
aS'str(i)'
p3274
aS"int('10')"
p3275
atp3276
Rp3277
sI1712227
g1
((lp3278
S'items.__len__()'
p3279
aS"items.append('apple')\nitems.append('orange')"
p3280
aS"items = []\nitems.append('apple')\nitems.append('orange')\nitems.append('banana')"
p3281
aS'def length(self):\n    pass'
p3282
aS'print l'
p3283
aS'l.length'
p3284
aS"items.append('banana')"
p3285
aS"items = []\nitems.append('apple')"
p3286
aS'len(items)'
p3287
aS"items.append('orange')"
p3288
aS'l.length\nprint l'
p3289
aS"items.append('apple')"
p3290
aS'l = slist(range(10))\nl.length'
p3291
aS'l = slist(range(10))\nl.length\nprint l'
p3292
aS'items = []'
p3293
aS'class slist(list):\n    pass'
p3294
aS'return len(self)'
p3295
aS'def length(self):\n    return len(self)'
p3296
aS'l = slist(range(10))'
p3297
aS"items.append('orange')\nitems.append('banana')"
p3298
aS"items = []\nitems.append('apple')\nitems.append('orange')"
p3299
aS'True'
p3300
aS'len([1, 2, 3])'
p3301
aS"items.append('apple')\nitems.append('orange')\nitems.append('banana')"
p3302
atp3303
Rp3304
sI1720421
g1
((lp3305
S'for item in itertools.chain(listone, listtwo):\n    pass'
p3306
aS'pass'
p3307
aS'mergedlist = list(set((listone + listtwo)))'
p3308
aS'mergedlist = (listone + listtwo)'
p3309
aS'import itertools'
p3310
aS'import itertools\nfor item in itertools.chain(listone, listtwo):\n    pass'
p3311
atp3312
Rp3313
sI209513
g1
((lp3314
S"int('0xa', 16)"
p3315
aS"x = int('deadbeef', 16)"
p3316
aS"print int('10', 0)"
p3317
aS"print int('0xdeadbeef', 0)"
p3318
aS'int(s, 16)'
p3319
aS"print int('0xdeadbeef', 0)\nprint int('10', 0)"
p3320
aS"int('a', 16)\nint('0xa', 16)"
p3321
aS"int('a', 16)"
p3322
atp3323
Rp3324
sI642154
g1
((lp3325
S'T2 = [[int(column) for column in row] for row in T1]'
p3326
aS'[[int(y) for y in x] for x in T1]'
p3327
aS'T2 = [parse_a_row_of_T1(row) for row in T1]'
p3328
aS"print (int('1') + 1)"
p3329
aS'T2 = [map(int, x) for x in T1]'
p3330
atp3331
Rp3332
sI2269827
g1
((lp3333
S"(chr(101) == 'e')\nhex(65)"
p3334
aS"hex(65)\n(chr(65) == 'A')"
p3335
aS'hex(65)'
p3336
aS"('0x%x' % 255)"
p3337
aS"(chr(101) == 'e')\nhex(65)\n(chr(65) == 'A')"
p3338
aS"(chr(65) == 'A')"
p3339
aS"(chr(101) == 'e')"
p3340
aS"strHex = ('0x%0.2X' % 255)"
p3341
aS"('0x%X' % 255)"
p3342
atp3343
Rp3344
sI6996603
g1
((lp3345
S'shutil.rmtree(path, ignore_errors=False, onerror=None)'
p3346
aS'os.removedirs(name)'
p3347
aS'os.rmdir'
p3348
aS'os.remove'
p3349
atp3350
Rp3351
sI227459
g1
((lp3352
S'chr(97)'
p3353
aS'ord()'
p3354
aS"chr((ord('a') + 3))"
p3355
aS'unichr(1234)'
p3356
aS"ord('a')\nchr(97)\nchr((ord('a') + 3))"
p3357
aS'unichr(97)'
p3358
aS"ord('a')\nchr(97)"
p3359
aS"ord('a')"
p3360
aS'unichr(97)\nunichr(1234)'
p3361
aS"ord(u'\\u3042')"
p3362
aS"chr(97)\nchr((ord('a') + 3))"
p3363
atp3364
Rp3365
sI9257094
g1
((lp3366
S"lower = raw_input('type in the same thing caps lock.')"
p3367
aS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p3368
aS'print upper.upper()\nprint lower.lower()'
p3369
aS'print s.upper()'
p3370
aS"s = 'sdsd'\ns.upper()"
p3371
aS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p3372
aS"s = 'sdsd'"
p3373
aS'import string'
p3374
aS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p3375
aS'string.ascii_uppercase'
p3376
aS"upper = raw_input('type in something lowercase.')"
p3377
aS's.upper()'
p3378
aS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p3379
aS'print upper.upper()'
p3380
aS'print lower.lower()'
p3381
aS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')"
p3382
aS'import string\nstring.ascii_uppercase'
p3383
aS"s = 'sdsd'\nprint s.upper()"
p3384
atp3385
Rp3386
sI730764
g1
((lp3387
S'sys.exit(1)'
p3388
aS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    raise'
p3389
aS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    pass'
p3390
aS'try:\n    doSomething()\nexcept Exception:\n    pass'
p3391
aS'try:\n    sys.exit(1)\nexcept Exception:\n    pass'
p3392
aS'try:\n    doSomething()\nexcept:\n    pass'
p3393
aS'try:\n    shutil.rmtree(path)\nexcept OSError:\n    pass'
p3394
aS'try:\n    sys.exit(1)\nexcept:\n    pass'
p3395
aS'pass'
p3396
aS"shutil.rmtree('/fake/dir')"
p3397
aS'try:\n    do_something()\nexcept:\n    pass'
p3398
aS'raise'
p3399
aS'do_something()'
p3400
aS'doSomething()'
p3401
aS'shutil.rmtree(path)'
p3402
aS'if (e.errno == 2):\n    pass'
p3403
aS'handle_exception()'
p3404
aS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    pass'
p3405
aS'try:\n    do_something()\nexcept:\n    handle_exception()'
p3406
aS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass'
p3407
aS'shutil.rmtree(2)'
p3408
aS'try:\n    do_something()\nexcept:\n    handle_exception()\nraise'
p3409
atp3410
Rp3411
sI70797
g1
((lp3412
S'import sys\nprint sys.argv'
p3413
aS"var = raw_input('Please enter something: ')"
p3414
aS"print 'you entered', var"
p3415
aS"input_var = input('Enter something: ')"
p3416
aS'import sys'
p3417
aS"input_var = input('Enter something: ')\nprint ('you entered ' + input_var)"
p3418
aS'print sys.argv'
p3419
aS"print ('you entered ' + input_var)"
p3420
aS"var = raw_input('Please enter something: ')\nprint 'you entered', var"
p3421
atp3422
Rp3423
sI4706499
g1
((lp3424
S"f.write('hi')"
p3425
aS'f.seek(0)'
p3426
aS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p3427
aS'f.seek(0)\nf.read()'
p3428
aS"f.write('hi')\nf.seek(0)"
p3429
aS"open('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p3430
aS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p3431
aS"open('test', 'rb').read()"
p3432
aS"f.seek(0)\nf.write('bye')"
p3433
aS"with open('foo', 'a') as f:\n    pass"
p3434
aS"f.write('bye')\nf.seek(0)\nf.read()"
p3435
aS"f.write('cool beans...')"
p3436
aS"myfile.write('appended text')"
p3437
aS"f = open('test', 'a+')"
p3438
aS"with open('test.txt', 'a') as myfile:\n    myfile.write('appended text')"
p3439
aS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p3440
aS"f.read()\nf.seek(0)\nf.write('bye')"
p3441
aS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p3442
aS"f.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p3443
aS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p3444
aS"f.seek(0)\nf.write('bye')\nf.seek(0)"
p3445
aS'f.seek(0)\nf.read()\nf.seek(0)'
p3446
aS"f.write('hi')\nf.seek(0)\nf.read()"
p3447
aS"open('test', 'a+b').write('koko')"
p3448
aS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p3449
aS"with open('foo', 'a') as f:\n    f.write('cool beans...')"
p3450
aS'f.read()\nf.seek(0)'
p3451
aS"with open('test.txt', 'a') as myfile:\n    pass"
p3452
aS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p3453
aS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p3454
aS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()"
p3455
aS"f.write('bye')"
p3456
aS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p3457
aS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')"
p3458
aS"'testkoko'"
p3459
aS"f = open('test', 'a+')\nf.write('hi')"
p3460
aS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p3461
aS"f.write('koko')"
p3462
aS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p3463
aS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)"
p3464
aS'f.read()'
p3465
aS"open('test', 'wb').write('test')"
p3466
aS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p3467
aS"f.write('test')"
p3468
aS'fseek(stream, 0, SEEK_END)'
p3469
aS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p3470
aS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p3471
aS"f.write('bye')\nf.seek(0)"
p3472
atp3473
Rp3474
sI22676
g1
((lp3475
S"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3476
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3477
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p3478
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p3479
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3480
aS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p3481
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3482
aS"file_name = url.split('/')[(-1)]"
p3483
aS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')"
p3484
aS'f.close()'
p3485
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3486
aS"urllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p3487
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3488
aS'import urllib'
p3489
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3490
aS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p3491
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p3492
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3493
aS"url = 'http://download.thinkbroadband.com/10MB.zip'"
p3494
aS'if (not buffer):\n    break\nfile_size_dl += len(buffer)'
p3495
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3496
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3497
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p3498
aS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3499
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3500
aS"f = open(file_name, 'wb')"
p3501
aS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p3502
aS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3503
aS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3504
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3505
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3506
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3507
aS'print status,\nf.close()'
p3508
aS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3509
aS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p3510
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3511
aS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3512
aS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p3513
aS'break'
p3514
aS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3515
aS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p3516
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3517
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p3518
aS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p3519
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p3520
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3521
aS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3522
aS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p3523
aS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p3524
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3525
aS'import requests'
p3526
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3527
aS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p3528
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3529
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p3530
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3531
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3532
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3533
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p3534
aS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p3535
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p3536
aS'handle.write(data)'
p3537
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3538
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3539
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3540
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3541
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3542
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3543
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3544
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3545
aS'file_size_dl = 0\nblock_sz = 8192'
p3546
aS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p3547
aS"f = open(file_name, 'wb')\nmeta = u.info()"
p3548
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3549
aS'print status,'
p3550
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3551
aS'status = (status + (chr(8) * (len(status) + 1)))'
p3552
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3553
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3554
aS'u = urllib2.urlopen(url)'
p3555
aS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p3556
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p3557
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3558
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3559
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3560
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3561
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3562
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3563
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3564
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p3565
aS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3566
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3567
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3568
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3569
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p3570
aS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3571
aS'if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p3572
aS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p3573
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3574
aS'response = requests.get(url, stream=True)'
p3575
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3576
aS'if (not buffer):\n    break'
p3577
aS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()'
p3578
aS'print len(r.content)'
p3579
aS"import urllib\nurllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p3580
aS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3581
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3582
aS'meta = u.info()'
p3583
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3584
aS'from tqdm import tqdm'
p3585
aS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p3586
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3587
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3588
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3589
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3590
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3591
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3592
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3593
aS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p3594
aS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3595
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3596
aS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3597
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p3598
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3599
aS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3600
aS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3601
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3602
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3603
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3604
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p3605
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3606
aS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p3607
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3608
aS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p3609
aS"with open('10MB', 'wb') as handle:\n    pass"
p3610
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3611
aS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p3612
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p3613
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3614
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3615
aS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p3616
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3617
aS'r = requests.get(url)\nprint len(r.content)'
p3618
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3619
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3620
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p3621
aS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3622
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3623
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3624
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3625
aS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3626
aS'import urllib2'
p3627
aS'for data in tqdm(response.iter_content()):\n    handle.write(data)'
p3628
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3629
aS'while True:\n    buffer = u.read(block_sz)'
p3630
aS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3631
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p3632
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p3633
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3634
aS'f.write(buffer)'
p3635
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3636
aS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3637
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3638
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3639
aS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3640
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3641
aS"file_size = int(meta.getheaders('Content-Length')[0])"
p3642
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p3643
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p3644
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p3645
aS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3646
aS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3647
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3648
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3649
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p3650
aS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p3651
aS'for data in tqdm(response.iter_content()):\n    pass'
p3652
aS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3653
aS'buffer = u.read(block_sz)'
p3654
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3655
aS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p3656
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3657
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p3658
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p3659
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3660
aS"response = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p3661
aS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass'
p3662
aS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p3663
aS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,'
p3664
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3665
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p3666
aS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p3667
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3668
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3669
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p3670
aS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3671
aS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p3672
aS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3673
aS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p3674
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3675
aS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p3676
aS'from tqdm import tqdm\nimport requests'
p3677
aS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3678
aS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p3679
aS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p3680
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p3681
aS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3682
aS'r = requests.get(url)'
p3683
aS'file_size_dl += len(buffer)'
p3684
aS'if (not buffer):\n    pass'
p3685
aS"response = urllib2.urlopen('http://www.example.com/')"
p3686
aS'file_size_dl = 0'
p3687
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3688
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3689
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p3690
aS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3691
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3692
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p3693
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p3694
aS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p3695
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p3696
aS'file_size_dl += len(buffer)\nf.write(buffer)'
p3697
aS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p3698
aS'block_sz = 8192'
p3699
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p3700
aS'html = response.read()'
p3701
aS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3702
aS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3703
aS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p3704
aS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p3705
aS'while True:\n    pass'
p3706
aS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p3707
aS'block_sz = 8192\nwhile True:\n    pass'
p3708
aS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p3709
aS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p3710
aS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p3711
aS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p3712
aS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p3713
atp3714
Rp3715
sI739993
g1
((lp3716
S"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p3717
aS'import os'
p3718
aS'import pip\ninstalled_packages = pip.get_installed_distributions()'
p3719
aS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p3720
aS"['behave==1.2.4', 'enum34==1.0', 'flask==0.10.1', 'itsdangerous==0.24', 'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3', 'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2', 'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1', 'vioozer-users-server==0.1', 'werkzeug==0.9.4']"
p3721
aS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p3722
aS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p3723
aS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p3724
aS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p3725
aS'(iterpipes == 0.4)'
p3726
aS'os.getcwd()'
p3727
aS'(docutils == 0.7)'
p3728
aS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p3729
aS"help('modules')"
p3730
aS'print installed_packages_list'
p3731
aS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p3732
aS'import pip'
p3733
aS'import os\nos.getcwd()'
p3734
aS'(cd / tmp)'
p3735
aS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p3736
aS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p3737
aS'installed_packages = pip.get_installed_distributions()'
p3738
aS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p3739
aS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p3740
atp3741
Rp3742
sI6797984
g1
((lp3743
S"raw_input('Type Something').lower()"
p3744
aS"s = 'Kilometer'"
p3745
aS"print s.lower()\nprint s.decode('utf-8').lower()"
p3746
aS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'"
p3747
aS"s = 'Kilometer'\nprint s.lower()"
p3748
aS"print s.decode('utf-8').lower()"
p3749
aS'print s.lower()'
p3750
aS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()\nprint s.decode('utf-8').lower()"
p3751
aS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()"
p3752
atp3753
Rp3754
sI1207457
g1
((lp3755
S'import codecs'
p3756
aS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'"
p3757
aS"s.encode('utf8')"
p3758
aS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'"
p3759
aS"s.encode('utf16')"
p3760
aS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')"
p3761
aS"type(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p3762
aS'type(a)'
p3763
aS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')"
p3764
aS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p3765
aS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p3766
aS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p3767
aS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata"
p3768
aS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p3769
aS"f = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p3770
aS'f.write(my_unicode_string)'
p3771
aS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)"
p3772
aS"s = u'\\xa310'\ns.encode('utf8')\ns.encode('utf16')"
p3773
aS"a.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p3774
aS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p3775
aS"s.encode('utf8')\ns.encode('utf16')"
p3776
aS"s = u'\\xa310'"
p3777
aS'import unicodedata'
p3778
aS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p3779
aS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p3780
aS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p3781
aS"f = codecs.open('path/to/file.txt', 'w', 'utf8')"
p3782
aS"a.encode('ascii', 'replace')"
p3783
aS"type(a)\na.encode('ascii', 'ignore')"
p3784
aS"s = u'\\xa310'\ns.encode('utf8')"
p3785
aS"a.encode('ascii', 'ignore')"
p3786
aS"'Kluft skrams infor pa federal electoral groe'"
p3787
atp3788
Rp3789
sI3294889
g1
((lp3790
S'for (key, value) in d.iteritems():\n    pass'
p3791
aS'd.keys()'
p3792
aS'for key in d:\n    pass'
p3793
aS"print k, 'corresponds to', v"
p3794
aS'for (key, value) in d.items():\n    pass'
p3795
aS'd.items()'
p3796
aS"print letter, 'corresponds to', number"
p3797
aS'list(d)'
p3798
aS'for (letter, number) in d.items():\n    pass'
p3799
aS'pass'
p3800
aS'for (k, v) in d.items():\n    pass'
p3801
aS"d = {'x': 1, 'y': 2, 'z': 3, }"
p3802
aS"print '{0} corresponds to {1}'.format(letter, number)"
p3803
aS"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)"
p3804
aS'list(d)\nd.keys()'
p3805
aS"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)\nd.keys()"
p3806
atp3807
Rp3808
sI7571635
g1
((lp3809
S"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p3810
aS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p3811
aS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p3812
aS'index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p3813
aS"print 'found'"
p3814
aS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))'
p3815
aS'(7 in a)'
p3816
aS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p3817
aS'a = [4, 2, 3, 1, 5, 6]'
p3818
aS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p3819
aS'try:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p3820
aS"return ('a' in a)"
p3821
aS"print 'Not found'"
p3822
aS'index = dict(((y, x) for (x, y) in enumerate(a)))'
p3823
aS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p3824
aS"a = [1, 2, 3, 4, 'a', 'b', 'c']"
p3825
aS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p3826
aS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p3827
aS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p3828
aS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p3829
aS"a = [1, 2, 3, 4, 'a', 'b', 'c']\nreturn ('a' in a)"
p3830
aS'a_index = index[7]'
p3831
atp3832
Rp3833
sI1093322
g1
((lp3834
S"import sys\nsys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p3835
aS'import sys'
p3836
aS'print sys.version'
p3837
aS"('%x' % sys.hexversion)"
p3838
aS'sys.version_info\nsys.hexversion'
p3839
aS'(python - V)'
p3840
aS"sys.hexversion\n('%x' % sys.hexversion)"
p3841
aS'sys.hexversion'
p3842
aS'assert (sys.version_info >= (2, 5))'
p3843
aS"('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p3844
aS"import sys\nsys.hexversion\n('%x' % sys.hexversion)"
p3845
aS'sys.version_info'
p3846
aS'import sys\nsys.hexversion'
p3847
aS'(sys.hexversion < 33947648)'
p3848
aS"sys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p3849
atp3850
Rp3851
sI5618878
g1
((lp3852
S"list1 = ['1', '2', '3']"
p3853
aS"list1 = ['1', '2', '3']\nstr1 = ''.join(list1)"
p3854
aS"L = ['L', 'O', 'L']\nmakeitastring = ''.join(map(str, L))"
p3855
aS"makeitastring = ''.join(map(str, L))"
p3856
aS"L = [1, 2, 3]\n' '.join((str(x) for x in L))\n'1 2 3'"
p3857
aS'L = [1, 2, 3]'
p3858
aS"str1 = ''.join(list1)"
p3859
aS"' '.join((str(x) for x in L))"
p3860
aS"str1 = ''.join((str(e) for e in list1))"
p3861
aS"list1 = [1, 2, 3]\nstr1 = ''.join((str(e) for e in list1))"
p3862
aS'list1 = [1, 2, 3]'
p3863
aS"L = ['L', 'O', 'L']"
p3864
aS"L = [1, 2, 3]\n' '.join((str(x) for x in L))"
p3865
aS"' '.join((str(x) for x in L))\n'1 2 3'"
p3866
aS"'1 2 3'"
p3867
atp3868
Rp3869
sI3277503
g1
((lp3870
S'array.append(line)'
p3871
aS"with open('filename') as f:\n    lines = f.readlines()"
p3872
aS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    pass"
p3873
aS'with open(fname) as f:\n    pass'
p3874
aS"with open('file.txt', 'r') as ins:\n    pass"
p3875
aS"with open('file.txt', 'r') as ins:\n    array = []"
p3876
aS'for line in ins:\n    array.append(line)'
p3877
aS'array = []'
p3878
aS'content = f.readlines()'
p3879
aS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    array.append(line)"
p3880
aS'lines = f.readlines()'
p3881
aS'with open(fname) as f:\n    content = f.readlines()'
p3882
aS"lines = [line.rstrip('\\n') for line in open('filename')]"
p3883
aS'for line in ins:\n    pass'
p3884
aS"with open('filename') as f:\n    pass"
p3885
atp3886
Rp3887
sI5844672
g1
((lp3888
S'def removekey(d, key):\n    r = dict(d)\ndel r[key]\nreturn r'
p3889
aS'a'
p3890
aS'del d[key]'
p3891
aS'del r[key]\nreturn r'
p3892
aS'{i: a[i] for i in a if (i != 0)}'
p3893
aS'def removekey(d, key):\n    pass'
p3894
aS'return r'
p3895
aS'a\n{i: a[i] for i in a if (i != 0)}'
p3896
aS'def removekey(d, key):\n    r = dict(d)'
p3897
aS'{}'
p3898
aS'def removekey(d, key):\n    r = dict(d)\ndel r[key]'
p3899
aS'del r[key]'
p3900
aS'r = dict(d)'
p3901
aS"'gdbye'"
p3902
atp3903
Rp3904
sI16296643
g1
((lp3905
S'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)\na[x][y] = 1'
p3906
aS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)'
p3907
aS'level1 = [list(row) for row in level1]'
p3908
aS'a = numpy.array(level1)'
p3909
aS'if (clicked[0] == 1):\n    pass'
p3910
aS"l = ['my', 'name', 'is', 'mr', 'list']\nl\ntuple(l)"
p3911
aS'a = numpy.array(level1)\na'
p3912
aS'level1 = map(list, level1)'
p3913
aS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt"
p3914
aS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)'
p3915
aS't\nlist(t)'
p3916
aS'[list(i) for i in level]'
p3917
aS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt\nlist(t)"
p3918
aS"l = ['my', 'name', 'is', 'mr', 'list']\nl"
p3919
aS'y = ((mousex + cameraX) // 60)\na[x][y] = 1'
p3920
aS'a'
p3921
aS'tuple((tuple(i) for i in edited))'
p3922
aS'list(t)'
p3923
aS"t = ('my', 'name', 'is', 'mr', 'tuple')"
p3924
aS'tuple(itertools.imap(tuple, edited))'
p3925
aS'x = ((mousey + cameraY) // 60)'
p3926
aS'tuple(l)'
p3927
aS'l'
p3928
aS'a[x][y] = 1'
p3929
aS'y = ((mousex + cameraX) // 60)'
p3930
aS'map(list, level)'
p3931
aS'l\ntuple(l)'
p3932
aS't'
p3933
aS"l = ['my', 'name', 'is', 'mr', 'list']"
p3934
atp3935
Rp3936
sI4004550
g1
((lp3937
S'floats = map(float, s.split())'
p3938
aS"s = '5.2 5.6 5.3'"
p3939
aS'floats = [float(x) for x in s.split()]'
p3940
aS"s = '5.2 5.6 5.3'\nfloats = [float(x) for x in s.split()]"
p3941
atp3942
Rp3943
sI10543303
g1
((lp3944
S'j = [4, 5, 6, 7, 1, 3, 7, 5]'
p3945
aS'j = np.array(j)'
p3946
aS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nsum(((i > 5) for i in j))'
p3947
aS'sum((j > i))'
p3948
aS'len([1 for i in j if (i > 5)])'
p3949
aS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nlen([1 for i in j if (i > 5)])'
p3950
aS'import numpy as np\nj = np.array(j)'
p3951
aS'sum(((i > 5) for i in j))'
p3952
aS'import numpy as np'
p3953
aS'issubclass(bool, int)'
p3954
aS'import numpy as np\nj = np.array(j)\nsum((j > i))'
p3955
aS'j = np.array(j)\nsum((j > i))'
p3956
atp3957
Rp3958
sI432842
g1
((lp3959
S'return (bool(str1) ^ bool(str2))'
p3960
aS'from operator import xor\nxor(bool(a), bool(b))'
p3961
aS'(bool(a) ^ bool(b))'
p3962
aS'((a and (not b)) or ((not a) and b))'
p3963
aS'xor(bool(a), bool(b))'
p3964
aS'def logical_xor(str1, str2):\n    pass'
p3965
aS'def logical_xor(str1, str2):\n    return (bool(str1) ^ bool(str2))'
p3966
aS'(bool(a) != bool(b))'
p3967
aS'from operator import xor'
p3968
atp3969
Rp3970
sI1303243
g1
((lp3971
S'(type(o) is str)'
p3972
aS'isinstance(o, str)'
p3973
aS'isinstance(o, basestring)'
p3974
aS'isinstance(obj_to_test, str)'
p3975
atp3976
Rp3977
sI163542
g1
((lp3978
S'p.stdin.close()'
p3979
aS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p3980
aS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p3981
aS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p3982
aS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)"
p3983
aS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p3984
aS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p3985
aS"pipe = os.popen(cmd, 'w', bufsize)"
p3986
aS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p3987
aS'print grep_stdout.decode()'
p3988
aS"pipe = os.popen(cmd, 'w', bufsize)\npipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin"
p3989
aS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p3990
aS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p3991
aS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p3992
aS'from subprocess import Popen, PIPE, STDOUT'
p3993
aS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p3994
aS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p3995
aS'p.communicate()[0]\np.stdin.close()'
p3996
aS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p3997
aS'p.communicate()[0]'
p3998
aS'pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin'
p3999
aS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p4000
aS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p4001
atp4002
Rp4003
sI306400
g1
((lp4004
S'group_of_items = {1, 2, 3, 4}'
p4005
aS'list_of_random_items = random.sample(group_of_items, num_to_select)'
p4006
aS"foo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p4007
aS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p4008
aS'num_to_select = 2'
p4009
aS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p4010
aS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange"
p4011
aS'from random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]'
p4012
aS'import random\ngroup_of_items = {1, 2, 3, 4}'
p4013
aS'random_index = randrange(0, len(foo))\nprint foo[random_index]'
p4014
aS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p4015
aS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p4016
aS'first_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p4017
aS'from random import randrange'
p4018
aS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p4019
aS'second_random_item = list_of_random_items[1]'
p4020
aS'from random import randrange\nrandom_index = randrange(0, len(foo))'
p4021
aS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p4022
aS'print foo[random_index]'
p4023
aS'first_random_item = list_of_random_items[0]'
p4024
aS'import random'
p4025
aS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]"
p4026
aS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p4027
aS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p4028
aS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']"
p4029
aS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p4030
aS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p4031
aS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p4032
aS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))"
p4033
aS"foo = ['a', 'b', 'c', 'd', 'e']"
p4034
aS'print random.choice(foo)'
p4035
aS'random_index = randrange(0, len(foo))'
p4036
aS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p4037
aS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p4038
aS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p4039
atp4040
Rp4041
sI3996904
g1
((lp4042
S'print random.randint(0, 9)'
p4043
aS'frand = uniform(0, 10)'
p4044
aS'irand = randrange(0, 10)'
p4045
aS'import random'
p4046
aS'import random\nprint random.randint(0, 9)'
p4047
aS'from random import randrange, uniform'
p4048
aS'from random import randint\nprint randint(0, 9)'
p4049
aS'from random import randrange, uniform\nirand = randrange(0, 10)'
p4050
aS'print randint(0, 9)'
p4051
aS'from random import randint'
p4052
aS'random.randint(a, b)'
p4053
aS'irand = randrange(0, 10)\nfrand = uniform(0, 10)'
p4054
aS'from random import randrange, uniform\nirand = randrange(0, 10)\nfrand = uniform(0, 10)'
p4055
atp4056
Rp4057
sI627435
g1
((lp4058
S'global index\na.pop(index)'
p4059
aS'def __init__(self, items):\n    pass'
p4060
aS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p4061
aS'def del_method():\n    global a'
p4062
aS'a = range(10)\nindex = 3'
p4063
aS'def pop_method():\n    global a\nglobal index\na.pop(index)'
p4064
aS'class foo(object):\n\n    def __init__(self, items):\n        pass'
p4065
aS'del a[index]'
p4066
aS'global index\na = (a[:index] + a[(index + 1):])'
p4067
aS'def del_method():\n    global a\nglobal index'
p4068
aS'index = 3\na = (a[:index] + a[(index + 1):])'
p4069
aS'def slice_method():\n    global a\nglobal index\na = (a[:index] + a[(index + 1):])'
p4070
aS'a\ndel a[(-1)]\na'
p4071
aS'return foo((self.items + right.items))'
p4072
aS'a.pop()'
p4073
aS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])'
p4074
aS'a = range(10)\na\ndel a[(-1)]'
p4075
aS'a = [1, 2, 3, 4, 5, 6]\nindex = 3'
p4076
aS'return foo(self.items[index])'
p4077
aS'a = [1, 2, 3, 4, 5, 6]\nindex = 3\na = (a[:index] + a[(index + 1):])'
p4078
aS'a = (a[:index] + a[(index + 1):])'
p4079
aS'class foo(object):\n    pass'
p4080
aS'a = range(10)\na\ndel a[(-1)]\na'
p4081
aS'del a[(-1)]\na'
p4082
aS'def slice_method():\n    global a\nglobal index'
p4083
aS'index = 3'
p4084
aS'a\ndel a[(-1)]'
p4085
aS'def del_method():\n    pass'
p4086
aS'a = range(10)\na'
p4087
aS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items'
p4088
aS'a.pop(1)'
p4089
aS'def slice_method():\n    global a'
p4090
aS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p4091
aS'def pop_method():\n    global a'
p4092
aS'def del_method():\n    global a\nglobal index\ndel a[index]'
p4093
aS'a = range(10)'
p4094
aS'self.items = items'
p4095
aS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    pass'
p4096
aS'global index\ndel a[index]'
p4097
aS'def __init__(self, items):\n    self.items = items'
p4098
aS'def pop_method():\n    pass'
p4099
aS'a.pop(index)'
p4100
aS'a'
p4101
aS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p4102
aS"a = ['a', 'b', 'c', 'd']\na.pop(1)"
p4103
aS'del a[(-1)]'
p4104
aS'global index'
p4105
aS'def __getitem__(self, index):\n    return foo(self.items[index])'
p4106
aS'def __add__(self, right):\n    pass'
p4107
aS"a = ['a', 'b', 'c', 'd']\na.pop()"
p4108
aS'def slice_method():\n    pass'
p4109
aS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p4110
aS"a = ['a', 'b', 'c', 'd']"
p4111
aS'def __add__(self, right):\n    return foo((self.items + right.items))'
p4112
aS'def pop_method():\n    global a\nglobal index'
p4113
aS'global a'
p4114
aS'a = [1, 2, 3, 4, 5, 6]'
p4115
aS'def __getitem__(self, index):\n    pass'
p4116
atp4117
Rp4118
sI1773805
g1
((lp4119
S"with open('example.yaml') as stream:\n    pass"
p4120
aS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p4121
aS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p4122
aS"with open('example.yaml', 'r') as stream:\n    pass"
p4123
aS'data_loaded = yaml.load(stream)'
p4124
aS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p4125
aS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p4126
aS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p4127
aS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p4128
aS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p4129
aS'print exc'
p4130
aS'import yaml'
p4131
aS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p4132
aS"with open('data.yaml', 'r') as stream:\n    pass"
p4133
aS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p4134
aS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p4135
aS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p4136
aS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p4137
aS'import ruamel.yaml as yaml'
p4138
aS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p4139
aS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p4140
aS'print (data == data_loaded)'
p4141
aS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p4142
aS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p4143
aS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p4144
aS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p4145
aS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p4146
aS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p4147
aS"import yaml\nwith open('example.yaml', 'r') as stream:\n    pass"
p4148
aS'yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)'
p4149
aS'import io'
p4150
aS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p4151
aS'print yaml.load(stream)'
p4152
aS'import yaml\nimport io'
p4153
aS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p4154
aS"import ruamel.yaml as yaml\nwith open('example.yaml') as stream:\n    pass"
p4155
aS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p4156
aS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p4157
aS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p4158
atp4159
Rp4160
sI663171
g1
((lp4161
S"x = 'Hello World!'"
p4162
aS"x = 'Hello World!'\nx[2:]"
p4163
aS'x[:2]\nx[:(-2)]\nx[(-2):]'
p4164
aS'x[:(-2)]\nx[(-2):]'
p4165
aS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]"
p4166
aS'x[(-2):]\nx[2:(-2)]'
p4167
aS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]"
p4168
aS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]"
p4169
aS'x[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p4170
aS'x[:(-2)]'
p4171
aS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]'
p4172
aS'x[2:]\nx[:2]'
p4173
aS'x[:2]\nx[:(-2)]'
p4174
aS"x = 'Hello World!'\nx[2:]\nx[:2]"
p4175
aS'x[2:]'
p4176
aS"'H-e-l-l-o- -W-o-r-l-d'[::2]"
p4177
aS'x[(-2):]'
p4178
aS'x[2:(-2)]'
p4179
aS's = Substr(s, beginning, LENGTH)'
p4180
aS'x[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p4181
aS'x[2:]\nx[:2]\nx[:(-2)]'
p4182
aS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p4183
aS'some_string[::(-1)]'
p4184
aS'x[:2]'
p4185
aS's = s[beginning:(beginning + LENGTH)]'
p4186
atp4187
Rp4188
sI1185524
g1
((lp4189
S'print s.strip()'
p4190
aS'import re'
p4191
aS'str.lstrip()\nstr.rstrip()'
p4192
aS'str.lstrip()'
p4193
aS'str.strip()\nstr.lstrip()'
p4194
aS"s = '   foo    \\t   '"
p4195
aS's = s.strip()'
p4196
aS"s = s.strip(' \\t\\n\\r')"
p4197
aS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p4198
aS"print pat.sub('', s)"
p4199
aS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p4200
aS"s = '   foo    \\t   '\nprint s.strip()"
p4201
aS"s = '  \\t a string example\\t  '\ns = s.strip()"
p4202
aS"import re\nprint re.sub('[\\\\s+]', '', s)"
p4203
aS's = s.rstrip()'
p4204
aS'str.strip()\nstr.lstrip()\nstr.rstrip()'
p4205
aS"print re.sub('[\\\\s+]', '', s)"
p4206
aS's = s.lstrip()'
p4207
aS'astringexample'
p4208
aS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p4209
aS"s = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p4210
aS'str.strip()'
p4211
aS"pat = re.compile('\\\\s+')"
p4212
aS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p4213
aS"import re\npat = re.compile('\\\\s+')"
p4214
aS"s = '  \\t a string example\\t  '"
p4215
aS'str.rstrip()'
p4216
aS"s = '  \\t  foo   \\t   bar \\t  '"
p4217
atp4218
Rp4219
sI354038
g1
((lp4220
S"b = '963spam'\nb.isdigit()"
p4221
aS"a = '03523'\na.isdigit()\nb = '963spam'\nb.isdigit()"
p4222
aS'a.isdigit()'
p4223
aS"a = '03523'"
p4224
aS"a = '03523'\na.isdigit()\nb = '963spam'"
p4225
aS"a.isdigit()\nb = '963spam'"
p4226
aS'b.isdigit()'
p4227
aS"b = '963spam'"
p4228
aS"a.isdigit()\nb = '963spam'\nb.isdigit()"
p4229
aS"float('NaN')"
p4230
aS"a = '03523'\na.isdigit()"
p4231
atp4232
Rp4233
sI2600191
g1
((lp4234
S'[1, 2, 3, 4, 1, 4, 1].count(1)'
p4235
aS'dict(((x, l.count(x)) for x in set(l)))'
p4236
aS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]"
p4237
aS"l = ['a', 'b', 'b']"
p4238
aS"l.count('b')"
p4239
aS"l = ['a', 'b', 'b']\nl.count('a')"
p4240
aS"l.count('a')"
p4241
aS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))"
p4242
aS'from collections import Counter\nCounter(l)'
p4243
aS'import timeit'
p4244
aS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p4245
aS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p4246
aS"print 'count():   ', t2.repeat(repeat=3, number=10000)"
p4247
aS"l.count('a')\nl.count('b')"
p4248
aS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p4249
aS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p4250
aS"l = ['a', 'b', 'b']\nl.count('a')\nl.count('b')"
p4251
aS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p4252
aS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p4253
aS'Counter(l)'
p4254
aS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p4255
aS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p4256
aS'[[x, l.count(x)] for x in set(l)]'
p4257
aS'from collections import Counter'
p4258
aS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p4259
aS"l = ['a', 'b', 'b']\nfrom collections import Counter\nCounter(l)"
p4260
aS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p4261
aS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p4262
aS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p4263
aS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p4264
aS"l = ['a', 'b', 'b']\nfrom collections import Counter"
p4265
aS'[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))'
p4266
aS'Counter(z)'
p4267
aS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p4268
aS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p4269
aS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p4270
aS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p4271
atp4272
Rp4273
sI845058
g1
((lp4274
S'def mapcount(filename):\n    pass'
p4275
aS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p4276
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p4277
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4278
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p4279
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4280
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4281
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p4282
aS'lines = 0'
p4283
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4284
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p4285
aS'from __future__ import with_statement'
p4286
aS'return lines\n\ndef bufcount(filename):\n    pass'
p4287
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p4288
aS'def simplecount(filename):\n    pass'
p4289
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p4290
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p4291
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p4292
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4293
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4294
aS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p4295
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4296
aS"def mapcount(filename):\n    f = open(filename, 'r+')"
p4297
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4298
aS'return lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4299
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p4300
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p4301
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4302
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p4303
aS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p4304
aS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4305
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4306
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4307
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass'
p4308
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4309
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4310
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4311
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p4312
aS'readline = buf.readline'
p4313
aS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p4314
aS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4315
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4316
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p4317
aS"print key.__name__, ':', (sum(vals) / float(len(vals)))"
p4318
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4319
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p4320
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4321
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p4322
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4323
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p4324
aS'pass'
p4325
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4326
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4327
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4328
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p4329
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4330
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p4331
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p4332
aS'lines += 1'
p4333
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4334
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4335
aS"f = open(filename, 'r+')"
p4336
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4337
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p4338
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4339
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p4340
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4341
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p4342
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4343
aS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4344
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p4345
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p4346
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p4347
aS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4348
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4349
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4350
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p4351
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4352
aS'buf = mmap.mmap(f.fileno(), 0)'
p4353
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4354
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p4355
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4356
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4357
aS'with open(fname) as f:\n    for (i, l) in enumerate(f):\n        pass'
p4358
aS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p4359
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4360
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4361
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4362
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4363
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p4364
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p4365
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4366
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p4367
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4368
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4369
aS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p4370
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p4371
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4372
aS'read_f = f.read'
p4373
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4374
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p4375
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4376
aS'buf = read_f(buf_size)\nreturn lines'
p4377
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p4378
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline'
p4379
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p4380
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p4381
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4382
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4383
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4384
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p4385
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p4386
aS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4387
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p4388
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4389
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4390
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4391
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4392
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4393
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4394
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4395
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4396
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4397
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4398
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p4399
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4400
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4401
aS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4402
aS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4403
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p4404
aS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p4405
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p4406
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4407
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4408
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p4409
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4410
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4411
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4412
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4413
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p4414
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4415
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4416
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4417
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4418
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4419
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4420
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p4421
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p4422
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4423
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4424
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p4425
aS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p4426
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p4427
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p4428
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4429
aS'read_f = f.read\nbuf = read_f(buf_size)'
p4430
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p4431
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4432
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4433
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4434
aS'import mmap\nimport random\nfrom collections import defaultdict'
p4435
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4436
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p4437
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4438
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p4439
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4440
aS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p4441
aS'import time\nimport mmap\nimport random\nfrom collections import defaultdict'
p4442
aS'buf_size = (1024 * 1024)\nread_f = f.read'
p4443
aS'from __future__ import with_statement\nimport time\nimport mmap\nimport random'
p4444
aS"lines += buf.count('\\n')"
p4445
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4446
aS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict'
p4447
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4448
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4449
aS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4450
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4451
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p4452
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4453
aS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4454
aS'for func in [mapcount, simplecount, bufcount, opcount]:\n    start_time = time.time()'
p4455
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p4456
aS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4457
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4458
aS'read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4459
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4460
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4461
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4462
aS'lines = 0\nbuf_size = (1024 * 1024)'
p4463
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4464
aS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4465
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4466
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p4467
aS'readline = buf.readline\nwhile readline():\n    lines += 1'
p4468
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4469
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4470
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4471
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4472
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4473
aS"num_lines = sum((1 for line in open('myfile.txt')))"
p4474
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p4475
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p4476
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4477
aS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4478
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p4479
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4480
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p4481
aS'for (key, vals) in counts.items():\n    pass'
p4482
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p4483
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p4484
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4485
aS'with open(fname) as f:\n    pass'
p4486
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4487
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4488
aS'readline = buf.readline\nwhile readline():\n    pass'
p4489
aS'for i in range(5):\n    pass'
p4490
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p4491
aS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4492
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4493
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4494
aS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4495
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4496
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p4497
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4498
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4499
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p4500
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4501
aS'counts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass'
p4502
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4503
aS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4504
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p4505
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p4506
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4507
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p4508
aS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4509
aS"while buf:\n    lines += buf.count('\\n')"
p4510
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p4511
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4512
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p4513
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4514
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p4515
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p4516
aS'lines = 0\nreadline = buf.readline'
p4517
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4518
aS'return lines\n\ndef simplecount(filename):\n    lines = 0'
p4519
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p4520
aS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p4521
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p4522
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p4523
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4524
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4525
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4526
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p4527
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p4528
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4529
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p4530
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4531
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4532
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p4533
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4534
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4535
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4536
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4537
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p4538
aS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4539
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4540
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4541
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4542
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4543
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4544
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p4545
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4546
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p4547
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4548
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p4549
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4550
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4551
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p4552
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p4553
aS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4554
aS'from collections import defaultdict'
p4555
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4556
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4557
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4558
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4559
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4560
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4561
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4562
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4563
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4564
aS'for line in open(filename):\n    lines += 1\nreturn lines'
p4565
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4566
aS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p4567
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4568
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4569
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4570
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4571
aS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4572
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4573
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4574
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4575
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4576
aS'for func in [mapcount, simplecount, bufcount, opcount]:\n    pass'
p4577
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p4578
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p4579
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4580
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p4581
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4582
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4583
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4584
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p4585
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4586
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4587
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p4588
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4589
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p4590
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p4591
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4592
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p4593
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4594
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p4595
aS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4596
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4597
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4598
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p4599
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4600
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4601
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p4602
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4603
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4604
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4605
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4606
aS'while readline():\n    lines += 1\nreturn lines'
p4607
aS'def simplecount(filename):\n    lines = 0'
p4608
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4609
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4610
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4611
aS'def bufcount(filename):\n    f = open(filename)\nlines = 0'
p4612
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p4613
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4614
aS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4615
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4616
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4617
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4618
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4619
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4620
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4621
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4622
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p4623
aS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4624
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4625
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4626
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4627
aS'for line in open(filename):\n    lines += 1'
p4628
aS'return lines'
p4629
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p4630
aS'counts[func].append((time.time() - start_time))'
p4631
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4632
aS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p4633
aS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4634
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4635
aS'import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p4636
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p4637
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4638
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4639
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4640
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p4641
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4642
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4643
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4644
aS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4645
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p4646
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4647
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4648
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4649
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4650
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4651
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p4652
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p4653
aS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p4654
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4655
aS'return (i + 1)'
p4656
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4657
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p4658
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4659
aS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p4660
aS'return (i + 1)\ncounts = defaultdict(list)'
p4661
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4662
aS'while readline():\n    pass'
p4663
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p4664
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4665
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p4666
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4667
aS'def opcount(fname):\n    pass'
p4668
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4669
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4670
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p4671
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p4672
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4673
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p4674
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p4675
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4676
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0'
p4677
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4678
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4679
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4680
aS'import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p4681
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p4682
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4683
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p4684
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p4685
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4686
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4687
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4688
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p4689
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4690
aS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4691
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4692
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4693
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4694
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4695
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p4696
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4697
aS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p4698
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p4699
aS'start_time = time.time()'
p4700
aS'return lines\n\ndef opcount(fname):\n    pass'
p4701
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4702
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4703
aS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p4704
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4705
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p4706
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p4707
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4708
aS'while buf:\n    pass'
p4709
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p4710
aS'from __future__ import with_statement\nimport time\nimport mmap'
p4711
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p4712
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p4713
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4714
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4715
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4716
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4717
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4718
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p4719
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p4720
aS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p4721
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4722
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p4723
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4724
aS'import time'
p4725
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4726
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p4727
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4728
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4729
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4730
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4731
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4732
aS"assert (func('big_file.txt') == 1209138)"
p4733
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p4734
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4735
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4736
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4737
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4738
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4739
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4740
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p4741
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4742
aS'import random\nfrom collections import defaultdict'
p4743
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4744
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p4745
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4746
aS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4747
aS'return lines\n\ndef simplecount(filename):\n    pass'
p4748
aS'import mmap'
p4749
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p4750
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4751
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4752
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p4753
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4754
aS'for (i, l) in enumerate(f):\n    pass'
p4755
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4756
aS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4757
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4758
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4759
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4760
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p4761
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4762
aS'from collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p4763
aS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4764
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p4765
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4766
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4767
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4768
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4769
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4770
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p4771
aS'import mmap\nimport random'
p4772
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p4773
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4774
aS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4775
aS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p4776
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4777
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p4778
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p4779
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4780
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4781
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4782
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4783
aS'import time\nimport mmap'
p4784
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p4785
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p4786
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4787
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p4788
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4789
aS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4790
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4791
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4792
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4793
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4794
aS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4795
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4796
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4797
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4798
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4799
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4800
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4801
aS'def opcount(fname):\n    with open(fname) as f:\n        pass'
p4802
aS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p4803
aS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4804
aS'buf_size = (1024 * 1024)'
p4805
aS'counts = defaultdict(list)'
p4806
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4807
aS'from __future__ import with_statement\nimport time'
p4808
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p4809
aS'while readline():\n    lines += 1'
p4810
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4811
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p4812
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p4813
aS'counts = defaultdict(list)\nfor i in range(5):\n    pass'
p4814
aS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4815
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4816
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4817
aS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p4818
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4819
aS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4820
aS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p4821
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p4822
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p4823
aS'def bufcount(filename):\n    pass'
p4824
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p4825
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4826
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p4827
aS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4828
aS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4829
aS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4830
aS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p4831
aS'f = open(filename)'
p4832
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p4833
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4834
aS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4835
aS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4836
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4837
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p4838
aS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4839
aS'for line in open(filename):\n    pass'
p4840
aS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4841
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4842
aS'def bufcount(filename):\n    f = open(filename)'
p4843
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4844
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p4845
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p4846
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4847
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4848
aS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p4849
aS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p4850
aS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p4851
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p4852
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p4853
aS'import time\nimport mmap\nimport random'
p4854
aS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4855
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p4856
aS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p4857
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p4858
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4859
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p4860
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p4861
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4862
aS'import random'
p4863
aS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4864
aS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p4865
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p4866
aS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p4867
aS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4868
aS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p4869
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p4870
aS'import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p4871
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p4872
aS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p4873
aS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p4874
aS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p4875
aS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4876
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p4877
aS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p4878
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4879
aS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p4880
aS'buf = read_f(buf_size)'
p4881
aS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p4882
aS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4883
aS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p4884
aS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p4885
aS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p4886
aS'buf = read_f(buf_size)\nwhile buf:\n    pass'
p4887
aS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4888
aS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p4889
aS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p4890
aS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p4891
aS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p4892
atp4893
Rp4894
sI6416131
g1
((lp4895
S'copy = self.copy()'
p4896
aS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()'
p4897
aS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4898
aS'class Dict(dict):\n\n    def __add__(self, other):\n        pass'
p4899
aS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p4900
aS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p4901
aS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p4902
aS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p4903
aS'def __add__(self, other):\n    copy = self.copy()'
p4904
aS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p4905
aS'copy.update(self)'
p4906
aS"(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4907
aS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p4908
aS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p4909
aS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p4910
aS'copy = other.copy()'
p4911
aS"default_data = Dict({'item1': 1, 'item2': 2, })"
p4912
aS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p4913
aS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p4914
aS'return copy\n\ndef __radd__(self, other):\n    pass'
p4915
aS"({'test1': 1, } + Dict(test2=2))"
p4916
aS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4917
aS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p4918
aS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p4919
aS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p4920
aS'class Dict(dict):\n    pass'
p4921
aS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4922
aS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy'
p4923
aS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p4924
aS'copy.update(other)'
p4925
aS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p4926
aS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4927
aS'copy.update(self)\nreturn copy'
p4928
aS'def __radd__(self, other):\n    copy = other.copy()'
p4929
aS'def __radd__(self, other):\n    pass'
p4930
aS"default_data['item3'] = 3"
p4931
aS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p4932
aS'return copy'
p4933
aS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p4934
aS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p4935
aS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p4936
aS'copy.update(other)\nreturn copy'
p4937
aS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)'
p4938
aS'def __add__(self, other):\n    pass'
p4939
aS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4940
aS"(default_data + {'item3': 3, })"
p4941
aS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p4942
aS"default_data.update({'item3': 3, })"
p4943
aS"default_data.update({'item4': 4, 'item5': 5, })"
p4944
aS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4945
aS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p4946
aS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p4947
aS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p4948
aS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p4949
aS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p4950
aS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p4951
aS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p4952
atp4953
Rp4954
sI3964681
g1
((lp4955
S"import glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p4956
aS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    pass"
p4957
aS"glob.glob('./*.txt')"
p4958
aS'import glob, os'
p4959
aS"for (root, dirs, files) in os.walk('/mydir'):\n    pass"
p4960
aS"for file in os.listdir('/mydir'):\n    pass"
p4961
aS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p4962
aS'import os'
p4963
aS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p4964
aS"for file in files:\n    if file.endswith('.txt'):\n        pass"
p4965
aS"import glob\nglob.glob('./*.txt')"
p4966
aS"os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p4967
aS"if file.endswith('.txt'):\n    pass"
p4968
aS'print file'
p4969
aS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p4970
aS"for file in glob.glob('*.txt'):\n    pass"
p4971
aS"import os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p4972
aS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p4973
aS'print os.path.join(root, file)'
p4974
aS'import glob'
p4975
aS"os.chdir('/mydir')"
p4976
aS'for file in files:\n    pass'
p4977
aS"import glob, os\nos.chdir('/mydir')"
p4978
aS"import os\nfor file in os.listdir('/mydir'):\n    pass"
p4979
aS"for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p4980
atp4981
Rp4982
sI849674
g1
((lp4983
S"import thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p4984
aS'print errtxt'
p4985
aS'pass'
p4986
aS'time.sleep(5)'
p4987
aS'print mystring'
p4988
aS'import thread, time'
p4989
aS't.join()'
p4990
aS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p4991
aS'while 1:\n    pass'
p4992
aS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    pass'
p4993
aS'from threading import Thread'
p4994
aS'import thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p4995
aS"def myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p4996
aS"import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p4997
aS'import thread'
p4998
aS'import thread\n\ndef myfunction(mystring, *args):\n    pass'
p4999
aS"Thread(target=myfunction, args=('MyStringHere', 1)).start()"
p5000
aS'def myfunction(mystring, *args):\n    pass'
p5001
aS'import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring'
p5002
aS'def myfunction(mystring, *args):\n    print mystring'
p5003
aS"if (__name__ == '__main__'):\n    pass"
p5004
aS"from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p5005
aS't.start()\nt.join()'
p5006
aS't.start()'
p5007
aS'import thread, time\n\ndef myfunction(mystring, *args):\n    pass'
p5008
aS"thread.start_new_thread(myfunction, ('MyStringHere', 1))"
p5009
aS"t = Thread(None, myfunction, None, ('MyStringHere', 1))"
p5010
atp5011
Rp5012
sI8270092
g1
((lp5013
S"pattern = re.compile('\\\\s+')"
p5014
aS'import re'
p5015
aS"import re\npattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p5016
aS"pattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p5017
aS"import re\npattern = re.compile('\\\\s+')"
p5018
aS"sentence = sentence.replace(' ', '')"
p5019
aS"sentence = re.sub('\\\\s+', '', sentence, flags=re.UNICODE)"
p5020
aS"'helloapple'"
p5021
aS'sentence = sentence.strip()'
p5022
aS"sentence = re.sub(pattern, '', sentence)"
p5023
aS"'hello  apple'"
p5024
aS"'hello apple'"
p5025
aS"sentence = ''.join(sentence.split())"
p5026
atp5027
Rp5028
sI7961363
g1
((lp5029
S"list(OrderedDict.fromkeys('abracadabra'))"
p5030
aS's = [1, 2, 3]\nlist((set(t) - set(s)))'
p5031
aS"list(dict.fromkeys('abracadabra'))"
p5032
aS't\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p5033
aS'list(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p5034
aS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt'
p5035
aS'from collections import OrderedDict'
p5036
aS'list((set(t) - set(s)))'
p5037
aS't\nlist(set(t))'
p5038
aS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]'
p5039
aS'list(set(t))'
p5040
aS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))'
p5041
aS't'
p5042
aS'list(set(t))\ns = [1, 2, 3]'
p5043
aS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p5044
aS's = [1, 2, 3]'
p5045
aS't\nlist(set(t))\ns = [1, 2, 3]'
p5046
aS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]'
p5047
aS"from collections import OrderedDict\nlist(OrderedDict.fromkeys('abracadabra'))"
p5048
atp5049
Rp5050
sI931092
g1
((lp5051
S'def reverse_a_string_slowly(a_string):\n    pass'
p5052
aS'def reversed_string(a_string):\n    return a_string[::(-1)]'
p5053
aS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]"
p5054
aS"return ''.join(reversed(string))"
p5055
aS'string[slice_obj]'
p5056
aS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p5057
aS'step = (-1)'
p5058
aS'def reversed_string(a_string):\n    pass'
p5059
aS"'foo'[::(-1)]"
p5060
aS"index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p5061
aS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1"
p5062
aS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p5063
aS'return a_string[::(-1)]'
p5064
aS'index = len(a_string)'
p5065
aS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p5066
aS"def reverse_a_string_slowly(a_string):\n    new_string = ''"
p5067
aS'def reverse_a_string_more_slowly(a_string):\n    pass'
p5068
aS"return ''.join(new_strings)"
p5069
aS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p5070
aS'start = stop = None\nstep = (-1)'
p5071
aS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)'
p5072
aS"'foo'[reverse_slice]"
p5073
aS'return new_string'
p5074
aS'slice_obj = slice(start, stop, step)'
p5075
aS'new_strings = []'
p5076
aS'index -= 1'
p5077
aS'while index:\n    index -= 1\nnew_string += a_string[index]'
p5078
aS'reverse_slice = slice(start, stop, step)'
p5079
aS"reverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p5080
aS"new_string = ''"
p5081
aS'new_strings.append(a_string[index])'
p5082
aS'while index:\n    pass'
p5083
aS"reversed_string('foo')"
p5084
aS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []'
p5085
aS'min(timeit.repeat((lambda : reversed_string(a_string))))'
p5086
aS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]'
p5087
aS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))"
p5088
aS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))'
p5089
aS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p5090
aS"'hello world'[::(-1)]"
p5091
aS'string[start:stop:step]'
p5092
aS'slice_obj = slice(start, stop, step)\nstring[slice_obj]'
p5093
aS"step = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p5094
aS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p5095
aS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1'
p5096
aS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p5097
aS'new_string += a_string[index]\nreturn new_string'
p5098
aS"new_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p5099
aS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)"
p5100
aS'new_string += a_string[index]'
p5101
aS'index = len(a_string)\nwhile index:\n    pass'
p5102
aS'start = stop = None'
p5103
aS"start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p5104
aS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))"
p5105
aS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))'
p5106
aS"def reverse_string_readable_answer(string):\n    return ''.join(reversed(string))"
p5107
aS"while index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p5108
aS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p5109
aS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))"
p5110
aS'start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)'
p5111
aS"a_string = ('amanaplanacanalpanama' * 10)"
p5112
aS"def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p5113
aS'while index:\n    index -= 1'
p5114
aS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p5115
aS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    pass"
p5116
aS'min(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p5117
aS'string[subscript]'
p5118
aS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string"
p5119
aS'step = (-1)\nreverse_slice = slice(start, stop, step)'
p5120
aS'index = len(a_string)\nwhile index:\n    index -= 1'
p5121
aS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    pass'
p5122
aS'def reverse_string_readable_answer(string):\n    pass'
p5123
aS'while index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p5124
aS'while index:\n    index -= 1\nnew_strings.append(a_string[index])'
p5125
aS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))"
p5126
atp5127
Rp5128
sI415511
g1
((lp5129
S'import datetime'
p5130
aS'from time import gmtime, strftime'
p5131
aS'datetime.datetime.now()'
p5132
aS'str(datetime.now())'
p5133
aS'datetime.datetime.time(datetime.datetime.now())'
p5134
aS'from datetime import datetime'
p5135
aS'datetime.datetime.now().time()'
p5136
aS'import datetime\ndatetime.datetime.now()'
p5137
aS"from time import gmtime, strftime\nstrftime('%Y-%m-%d %H:%M:%S', gmtime())"
p5138
aS"strftime('%Y-%m-%d %H:%M:%S', gmtime())"
p5139
aS'from datetime import datetime\nstr(datetime.now())'
p5140
atp5141
Rp5142
sI14043934
g1
((lp5143
S'import datetime'
p5144
aS'dt = datetime.datetime.combine(datetime.date.today(), t)'
p5145
aS'dt\ndt -= datetime.timedelta(hours=5)'
p5146
aS't = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p5147
aS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)'
p5148
aS'dt.time()'
p5149
aS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p5150
aS'dt -= datetime.timedelta(hours=5)\ndt.time()'
p5151
aS'(t - datetime.timedelta(hours=1, minutes=10))'
p5152
aS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p5153
aS't = datetime.time(1, 2)'
p5154
aS'dt'
p5155
aS'dt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p5156
aS'import datetime\nt = datetime.datetime.now()'
p5157
aS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p5158
aS'import datetime\nt = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p5159
aS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p5160
aS't = datetime.datetime.now()'
p5161
aS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p5162
aS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p5163
aS'dt -= datetime.timedelta(hours=5)'
p5164
atp5165
Rp5166
sI3940128
g1
((lp5167
S'array = [0, 10, 20, 40]'
p5168
aS'L = [0, 10, 20, 40]\nL.reverse()\nL'
p5169
aS'array = [0, 10, 20, 40]\nfor i in reversed(array):\n    pass'
p5170
aS'L = [0, 10, 20, 40]\nL.reverse()'
p5171
aS'L = [0, 10, 20, 40]\nL[::(-1)]'
p5172
aS'print i'
p5173
aS'L'
p5174
aS'L = [0, 10, 20, 40]'
p5175
aS'L[::(-1)]'
p5176
aS'L.reverse()\nL'
p5177
aS'for i in reversed(array):\n    pass'
p5178
aS'L.reverse()'
p5179
atp5180
Rp5181
sI1949318
g1
((lp5182
S'200'
p5183
aS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p5184
aS'def url_ok(url):\n    r = requests.head(url)'
p5185
aS'import httplib'
p5186
aS'r = requests.head(url)'
p5187
aS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p5188
aS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p5189
aS"conn = httplib.HTTPConnection('www.python.org')"
p5190
aS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p5191
aS'r1 = conn.getresponse()\nprint r1.status, r1.reason'
p5192
aS'return (r.status_code == 200)'
p5193
aS"conn.request('HEAD', '/')\nr1 = conn.getresponse()"
p5194
aS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)'
p5195
aS'def url_ok(url):\n    pass'
p5196
aS'def url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p5197
aS'import requests\n\ndef url_ok(url):\n    pass'
p5198
aS'import requests'
p5199
aS"conn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p5200
aS'r1 = conn.getresponse()'
p5201
aS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p5202
aS"print urllib.urlopen('http://www.stackoverflow.com').getcode()"
p5203
aS"import httplib\nconn = httplib.HTTPConnection('www.python.org')"
p5204
aS'print r1.status, r1.reason'
p5205
aS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p5206
aS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p5207
aS"conn.request('HEAD', '/')"
p5208
aS"print urllib.urlopen('http://www.stackoverflow.com').getcode()\n200"
p5209
atp5210
Rp5211
sI2052390
g1
((lp5212
S'"foo should be either \'baz\' or \'bar\'. returns something very useful."'
p5213
aS'if (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p5214
aS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    pass'
p5215
aS"raise Exception('I know python!')"
p5216
aS'raise AppError, error, sys.exc_info()[2]\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p5217
aS'raise AppError, error, sys.exc_info()[2]'
p5218
aS'print err.args'
p5219
aS"raise 'message'"
p5220
aS"raise Exception('I know Python!')"
p5221
aS'if (0 < distance <= RADIUS):\n    pass'
p5222
aS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    pass'
p5223
aS'demo_no_catch()'
p5224
aS'class MyAppLookupError(LookupError):\n    pass'
p5225
aS'do_something_in_app_that_breaks_easily()'
p5226
aS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)'
p5227
aS"raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz')"
p5228
aS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\nraise'
p5229
aS"('message', 'foo', 'bar', 'baz')"
p5230
aS'if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    pass'
p5231
aS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print err.args'
p5232
aS'class MyAppLookupError(LookupError):\n    "raise this when there\'s a lookup error for my app"'
p5233
aS'raise'
p5234
aS'if (foo not in _ALLOWED_ARGS):\n    pass'
p5235
aS"raise ValueError('A very specific bad thing happened')"
p5236
aS'raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p5237
aS'logger.error(error)'
p5238
aS"raise MyAppLookupError('resource is missing, and that is not ok.')"
p5239
aS'some_code_that_may_raise_our_value_error()'
p5240
aS'"raise this when there\'s a lookup error for my app"'
p5241
aS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    pass'
p5242
aS'raise AssertionError("Unexpected value of \'distance\'!", distance)'
p5243
aS"raise ValueError, 'message'"
p5244
aS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."'
p5245
aS'raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p5246
aS'demo_bad_catch()'
p5247
aS"if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    raise MyAppLookupError('resource is missing, and that is not ok.')"
p5248
aS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p5249
aS'def api_func(foo):\n    pass'
p5250
aS'raise error.with_traceback(sys.exc_info()[2])'
p5251
atp5252
Rp5253
sI2331943
g1
((lp5254
S'try:\n    import json\nexcept ImportError:\n    pass'
p5255
aS'import urllib2'
p5256
aS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p5257
aS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p5258
aS'import json'
p5259
aS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p5260
aS'u.close()'
p5261
aS'try:\n    import json\nexcept ImportError:\n    import simplejson as json'
p5262
aS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p5263
aS'import urllib2\nimport json'
p5264
aS'import simplejson as json'
p5265
aS'print json.load(u)'
p5266
aS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p5267
aS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p5268
aS'print json.load(u)\nu.close()'
p5269
aS"u = urllib2.urlopen('http://www.reddit.com/.json')"
p5270
aS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p5271
aS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p5272
atp5273
Rp5274
sI273192
g1
((lp5275
S'try:\n    os.makedirs(path)\nexcept OSError:\n    pass'
p5276
aS'os.makedirs(path, exist_ok=True)'
p5277
aS'if (not os.path.exists(directory)):\n    os.makedirs(directory)'
p5278
aS'if (not os.path.exists(directory)):\n    pass'
p5279
aS'import errno\n\ndef make_sure_path_exists(path):\n    pass'
p5280
aS'if (not os.path.isdir(path)):\n    pass'
p5281
aS'os.makedirs(directory)'
p5282
aS'distutils.dir_util.mkpath(path)'
p5283
aS'os.makedirs(path)'
p5284
aS'if (not os.path.isdir(path)):\n    raise'
p5285
aS'def make_sure_path_exists(path):\n    pass'
p5286
aS'if (exception.errno != errno.EEXIST):\n    raise'
p5287
aS'import distutils.dir_util'
p5288
aS'raise'
p5289
aS'import distutils.dir_util\ndistutils.dir_util.mkpath(path)'
p5290
aS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        raise'
p5291
aS'import os'
p5292
aS'import os\nimport errno\n\ndef make_sure_path_exists(path):\n    pass'
p5293
aS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        pass'
p5294
aS'import os\nimport errno'
p5295
aS'if (exception.errno != errno.EEXIST):\n    pass'
p5296
aS'import errno'
p5297
atp5298
Rp5299
sI4020539
g1
((lp5300
S'import codecs'
p5301
aS"myString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p5302
aS"decoded_string = myString.decode('string_escape')\nprint decoded_string"
p5303
aS"return codecs.decode(match.group(0), 'unicode-escape')"
p5304
aS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p5305
aS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p5306
aS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p5307
aS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p5308
aS'print decoded_string'
p5309
aS"s = 'na\\xc3\\xafve \\\\t test'"
p5310
aS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p5311
aS"def decode_match(match):\n    return codecs.decode(match.group(0), 'unicode-escape')"
p5312
aS"myString = 'na\\xc3\\xafve \\\\t test'"
p5313
aS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p5314
aS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p5315
aS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p5316
aS'def decode_match(match):\n    pass'
p5317
aS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p5318
aS"import codecs\nprint codecs.decode(s, 'unicode_escape')"
p5319
aS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p5320
aS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p5321
aS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p5322
aS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p5323
aS"print decode_escapes('Ern\\xc5\\x91 \\\\t Rubik')"
p5324
aS'return ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p5325
aS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p5326
aS"print 'Ern\\xc5\\x91 \\\\t Rubik'.encode('latin-1').decode('unicode_escape')"
p5327
aS"decoded_string = myString.decode('string_escape')"
p5328
aS'import re\nimport codecs'
p5329
aS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p5330
aS'import re'
p5331
aS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p5332
aS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')"
p5333
aS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)"
p5334
aS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p5335
aS'def decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p5336
aS"import codecs\nmyString = 'spam\\\\neggs'"
p5337
aS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p5338
aS"s = 'na\\xc3\\xafve \\\\t test'\nprint s.encode('utf-8').decode('unicode_escape')"
p5339
aS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p5340
aS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p5341
aS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p5342
aS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p5343
aS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p5344
aS"myString = 'spam\\\\neggs'"
p5345
aS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p5346
aS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p5347
aS'def decode_escapes(s):\n    pass'
p5348
aS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p5349
aS"print codecs.decode(s, 'unicode_escape')"
p5350
aS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p5351
aS"print s.encode('utf-8').decode('unicode_escape')"
p5352
aS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p5353
aS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p5354
aS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p5355
aS"print s.encode('latin-1').decode('unicode_escape')"
p5356
atp5357
Rp5358
sI21129020
g1
((lp5359
S'my_unicode_string = my_file.read()'
p5360
aS'import sys\nreload(sys)\nsys.getdefaultencoding()'
p5361
aS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p5362
aS'import sys'
p5363
aS"source = unicode(source, 'utf-8')"
p5364
aS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p5365
aS"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    pass"
p5366
aS"u'The currency is: {}'.format('\\xe2\\x82\\xac')"
p5367
aS"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    my_unicode_string = my_file.read()"
p5368
aS"charset = ('utf8',)\nuse_unicode = True"
p5369
aS'reload(sys)'
p5370
aS'reload(sys)\nsys.getdefaultencoding()'
p5371
aS"u'Z\\xfcrich'"
p5372
aS'use_unicode = True'
p5373
aS"sys.setdefaultencoding('utf8')"
p5374
aS'sys.getdefaultencoding()'
p5375
aS"(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p5376
aS"charset = ('utf8',)"
p5377
aS"(u'The currency is: ' + '\\xe2\\x82\\xac')"
p5378
aS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'"
p5379
aS'import sys\nreload(sys)'
p5380
aS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p5381
aS'type(my_u)'
p5382
aS"unicode('\\xe2\\x82\\xac')"
p5383
aS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p5384
aS"reload(sys)\nsys.setdefaultencoding('utf8')"
p5385
aS"(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p5386
aS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p5387
aS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')"
p5388
aS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)\npsycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p5389
aS"import sys\nreload(sys)\nsys.setdefaultencoding('utf8')"
p5390
aS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)'
p5391
aS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'\ntype(my_u)"
p5392
atp5393
Rp5394
sI1854
g1
((lp5395
S'import platform\nplatform.system()\nplatform.release()'
p5396
aS'import os\nos.name'
p5397
aS'platform.system()'
p5398
aS'import os\nprint os.name\nimport platform\nplatform.system()'
p5399
aS'import platform\nplatform.system()'
p5400
aS'import os\nos.name\nimport platform\nplatform.system()'
p5401
aS'import os'
p5402
aS'import platform'
p5403
aS'print os.name\nimport platform\nplatform.system()\nplatform.release()'
p5404
aS'os.name'
p5405
aS'platform.release()'
p5406
aS'print os.name\nimport platform\nplatform.system()'
p5407
aS'os.name\nimport platform\nplatform.system()'
p5408
aS'os.name\nimport platform'
p5409
aS'os.name\nimport platform\nplatform.system()\nplatform.release()'
p5410
aS'print os.name\nimport platform'
p5411
aS'import os\nprint os.name\nimport platform'
p5412
aS'print os.name'
p5413
aS'import os\nos.name\nimport platform\nplatform.system()\nplatform.release()'
p5414
aS'import os\nprint os.name\nimport platform\nplatform.system()\nplatform.release()'
p5415
aS'platform.system()\nplatform.release()'
p5416
aS'import os\nprint os.name'
p5417
aS'import os\nos.name\nimport platform'
p5418
atp5419
Rp5420
sI613183
g1
((lp5421
S'd = defaultdict(int)\nfor w in text.split():\n    pass'
p5422
aS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p5423
aS'for w in text.split():\n    d[w] += 1'
p5424
aS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p5425
aS'd = defaultdict(int)\nfor w in text.split():\n    d[w] += 1'
p5426
aS'for w in sorted(d, key=d.get, reverse=True):\n    pass'
p5427
aS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p5428
aS'd = defaultdict(int)'
p5429
aS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p5430
aS'sorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p5431
aS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p5432
aS'import operator'
p5433
aS'd[w] += 1'
p5434
aS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p5435
aS'for w in text.split():\n    pass'
p5436
aS'print w, d[w]'
p5437
aS'sorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p5438
atp5439
Rp5440
sI3501382
g1
((lp5441
S'if (type(val) == int):\n    return True'
p5442
aS'x = Spam(0)'
p5443
aS'(type(x) == int)'
p5444
aS'try:\n    x += 1\nexcept TypeError:\n    pass'
p5445
aS'return False'
p5446
aS'float(5).is_integer()\nfloat(5.1).is_integer()\nfloat(5.0).is_integer()'
p5447
aS'def is_int(val):\n    if (type(val) == int):\n        return True'
p5448
aS'x += 1'
p5449
aS'float(5.1).is_integer()\nfloat(5.0).is_integer()'
p5450
aS'for index in range(y):\n    pass'
p5451
aS'pass'
p5452
aS'float(5).is_integer()\nfloat(5.1).is_integer()'
p5453
aS'import numbers\nisinstance(3, numbers.Integral)'
p5454
aS'import numbers'
p5455
aS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)'
p5456
aS'float(5).is_integer()'
p5457
aS'def is_int(val):\n    if (type(val) == int):\n        pass'
p5458
aS'float(5.1).is_integer()'
p5459
aS'class Spam(int):\n    pass\nx = Spam(0)'
p5460
aS'return True'
p5461
aS'isinstance(3, numbers.Integral)'
p5462
aS'if (type(val) == int):\n    pass'
p5463
aS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p5464
aS'float(5.0).is_integer()'
p5465
aS'def is_int(val):\n    pass'
p5466
aS'(type(x) == int)\nisinstance(x, int)'
p5467
aS'x = Spam(0)\n(type(x) == int)'
p5468
aS'class Spam(int):\n    pass'
p5469
aS'isinstance(x, int)'
p5470
aS'x = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p5471
atp5472
Rp5473
sI89228
g1
((lp5474
S'import subprocess'
p5475
aS"return_code = subprocess.call('echo Hello World', shell=True)"
p5476
aS'from subprocess import call'
p5477
aS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p5478
aS"print os.popen('echo Hello World').read()"
p5479
aS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p5480
aS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p5481
aS'for line in p.stdout.readlines():\n    pass'
p5482
aS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p5483
aS'for line in p.stdout.readlines():\n    print line,\nretval = p.wait()'
p5484
aS'retval = p.wait()'
p5485
aS'print line,'
p5486
aS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p5487
aS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p5488
aS"print subprocess.Popen(('echo %s ' % user_input), stdout=PIPE).stdout.read()"
p5489
aS"os.system('some_command < input_file | another_command > output_file')"
p5490
aS"from subprocess import call\ncall(['ls', '-l'])"
p5491
aS"print subprocess.Popen('echo Hello World', shell=True, stdout=subprocess.PIPE).stdout.read()"
p5492
aS"call(['ls', '-l'])"
p5493
atp5494
Rp5495
sI493386
g1
((lp5496
S'print i,'
p5497
aS"import sys\nsys.stdout.write('.')"
p5498
aS"print ('Item %d: %s' % (i, strings[i]))"
p5499
aS'import sys'
p5500
aS'sys.stdout.flush()'
p5501
aS"strings = ['one', 'two', 'three']\nfor i in xrange(3):\n    pass"
p5502
aS'from __future__ import print_function'
p5503
aS'for i in xrange(3):\n    pass'
p5504
aS'for i in range(10):\n    pass'
p5505
aS"strings = ['one', 'two', 'three']"
p5506
aS'print'
p5507
aS"sys.stdout.write('.')"
p5508
aS'for i in range(10):\n    print i,\nelse:\n    pass'
p5509
aS'for i in range(10):\n    print i,\nelse:\n    print'
p5510
aS"print ('.' * 10)"
p5511
atp5512
Rp5513
sI311627
g1
((lp5514
S"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5515
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p5516
aS'import datetime\nmylist = []\ntoday = datetime.date.today()'
p5517
aS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p5518
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())"
p5519
aS"print 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5520
aS"print ('This is a new day : ' + mylist[0])"
p5521
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5522
aS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5523
aS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5524
aS'today = datetime.date.today()\nmylist.append(today)'
p5525
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5526
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())"
p5527
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5528
aS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p5529
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5530
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5531
aS"print 'Current date and time: ', datetime.datetime.now()"
p5532
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p5533
aS"mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p5534
aS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5535
aS"print 'Day of year: ', datetime.date.today().strftime('%j')"
p5536
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p5537
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5538
aS'mylist.append(today)\nprint mylist[0]'
p5539
aS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5540
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5541
aS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5542
aS"print 'We are the {:%d, %b %Y}'.format(today)\n'We are the 22, Nov 2008'"
p5543
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p5544
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5545
aS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p5546
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p5547
aS"import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p5548
aS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5549
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p5550
aS"((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p5551
aS"print mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p5552
aS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p5553
aS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5554
aS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5555
aS"print today.strftime('We are the %d, %b %Y')"
p5556
aS'import time\nimport datetime'
p5557
aS'import datetime\nmylist = []'
p5558
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5559
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5560
aS'for date in mylist:\n    pass'
p5561
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5562
aS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5563
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p5564
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p5565
aS'print mylist[0]\n((2008 - 11) - 22)'
p5566
aS'import datetime'
p5567
aS"import time\nprint time.strftime('%Y-%m-%d %H:%M')"
p5568
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5569
aS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5570
aS"mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p5571
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p5572
aS"import datetime\nprint datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p5573
aS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5574
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5575
aS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p5576
aS"print 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5577
aS'((2008 - 11) - 22)'
p5578
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p5579
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p5580
aS"print 'This is a new day : ', mylist[0]"
p5581
aS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5582
aS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5583
aS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5584
aS'import time'
p5585
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5586
aS"'We are the 22, Nov 2008'"
p5587
aS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p5588
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5589
aS"print 'Current year: ', datetime.date.today().strftime('%Y')"
p5590
aS"print time.strftime('%Y-%m-%d %H:%M')"
p5591
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5592
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p5593
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5594
aS'mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p5595
aS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p5596
aS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5597
aS"print datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p5598
aS'mylist = []'
p5599
aS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5600
aS'today = datetime.date.today()'
p5601
aS"today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p5602
aS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5603
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p5604
aS'print mylist[0]'
p5605
aS"print 'Day of week: ', datetime.date.today().strftime('%A')"
p5606
aS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p5607
aS"print 'Day of the month : ', datetime.date.today().strftime('%d')"
p5608
aS"print ('This is a new day : ' + str(mylist[0]))"
p5609
aS"print 'We are the {:%d, %b %Y}'.format(today)"
p5610
aS'print str(date)'
p5611
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p5612
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5613
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p5614
aS"print 'Month of year: ', datetime.date.today().strftime('%B')"
p5615
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p5616
aS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5617
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p5618
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p5619
aS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5620
aS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5621
aS"print ('Time in seconds since the epoch: %s' % time.time())"
p5622
aS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p5623
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p5624
aS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p5625
aS'mylist.append(today)'
p5626
aS"print today.strftime('We are the %d, %b %Y')\n'We are the 22, Nov 2008'"
p5627
aS'mylist = []\ntoday = datetime.date.today()'
p5628
aS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p5629
aS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5630
aS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p5631
aS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p5632
atp5633
Rp5634
sI1024847
g1
((lp5635
S"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p5636
aS'print x\nx.update({3: 4, })\nprint x'
p5637
aS'data.pop(key)\ndata.clear()'
p5638
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p5639
aS"data.update({'a': 1, })"
p5640
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p5641
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p5642
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p5643
aS'data.update(a=1)\ndata.update(data2)'
p5644
aS"data['a'] = 1\ndata.update({'a': 1, })"
p5645
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p5646
aS'del data[key]\ndata.pop(key)'
p5647
aS'data = {}\ndata = dict()'
p5648
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p5649
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p5650
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p5651
aS'x.update({3: 4, })\nprint x'
p5652
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p5653
aS"d = {'key': 'value', }"
p5654
aS'data.update(dict(a=1))'
p5655
aS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p5656
aS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p5657
aS'data.update(a=1)\ndata.update(data2)\ndel data[key]'
p5658
aS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p5659
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p5660
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p5661
aS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p5662
aS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p5663
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p5664
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p5665
aS"data = {'a': 1, 'b': 2, 'c': 3, }"
p5666
aS'data.pop(key)'
p5667
aS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p5668
aS'data.clear()'
p5669
aS'x = {1: 2, }'
p5670
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p5671
aS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p5672
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p5673
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p5674
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p5675
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p5676
aS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p5677
aS'data.update(data2)'
p5678
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p5679
aS'data.update(dict(a=1))\ndata.update(a=1)'
p5680
aS'data = dict(a=1, b=2, c=3)'
p5681
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p5682
aS'x = {1: 2, }\nprint x\nx.update({3: 4, })\nprint x'
p5683
aS'data.update(a=1)'
p5684
aS"data['a'] = 1"
p5685
aS"d['mynewkey'] = 'mynewvalue'"
p5686
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p5687
aS"d = {'key': 'value', }\nprint d"
p5688
aS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]'
p5689
aS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)'
p5690
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p5691
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p5692
aS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p5693
aS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p5694
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p5695
aS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p5696
aS'print d'
p5697
aS'del data[key]\ndata.pop(key)\ndata.clear()'
p5698
aS'data.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p5699
aS'data.update(data2)\ndel data[key]\ndata.pop(key)'
p5700
aS'x.update({3: 4, })'
p5701
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p5702
aS'x = {1: 2, }\nprint x'
p5703
aS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p5704
aS'print x'
p5705
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p5706
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p5707
aS'data = dict()'
p5708
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p5709
aS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'"
p5710
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p5711
aS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p5712
aS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p5713
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p5714
aS'print x\nx.update({3: 4, })'
p5715
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p5716
aS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p5717
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p5718
aS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p5719
aS'data = {}'
p5720
aS"data.update({'a': 1, })\ndata.update(dict(a=1))"
p5721
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p5722
aS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p5723
aS'data.update(data2)\ndel data[key]'
p5724
aS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p5725
aS"d['mynewkey'] = 'mynewvalue'\nprint d"
p5726
aS"print d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p5727
aS"print d\nd['mynewkey'] = 'mynewvalue'"
p5728
aS'del data[key]'
p5729
aS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p5730
aS'x = {1: 2, }\nprint x\nx.update({3: 4, })'
p5731
atp5732
Rp5733
sI120656
g1
((lp5734
S"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p5735
aS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p5736
aS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p5737
aS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p5738
aS'for subdirname in dirnames:\n    pass'
p5739
aS'import os'
p5740
aS"for (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p5741
aS'print filename'
p5742
aS'for filename in filenames:\n    pass'
p5743
aS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p5744
aS"import os\nfor filename in os.listdir('C:\\\\temp'):\n    pass"
p5745
aS'os.listdir(path)'
p5746
aS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p5747
aS"for filename in os.listdir('C:\\\\temp'):\n    pass"
p5748
aS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p5749
aS'print os.path.join(dirname, subdirname)'
p5750
aS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p5751
aS"if ('.git' in dirnames):\n    pass"
p5752
aS"dirnames.remove('.git')"
p5753
aS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p5754
aS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p5755
aS'print os.path.join(dirname, filename)'
p5756
aS"if ('.git' in dirnames):\n    dirnames.remove('.git')"
p5757
aS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p5758
atp5759
Rp5760
sI2150739
g1
((lp5761
S'import datetime'
p5762
aS"from datetime import datetime\ndatetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p5763
aS'datetime.datetime.now().isoformat()'
p5764
aS'def utcoffset(self, dt):\n    pass'
p5765
aS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p5766
aS'def utcoffset(self, dt):\n    return timedelta(minutes=(-399))'
p5767
aS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p5768
aS'datetime.datetime.utcnow().isoformat()'
p5769
aS'from datetime import datetime'
p5770
aS"strftime('%Y-%m-%d %H:%M:%S')"
p5771
aS"datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p5772
aS"datetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p5773
aS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p5774
aS'class TZ(tzinfo):\n    pass'
p5775
aS'return timedelta(minutes=(-399))'
p5776
aS'from datetime import tzinfo, timedelta, datetime'
p5777
aS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p5778
aS'datetime.fromtimestamp(x)'
p5779
aS"from time import strftime\nstrftime('%Y-%m-%d %H:%M:%S')"
p5780
aS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n    pass'
p5781
aS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p5782
aS"x = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p5783
aS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p5784
aS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p5785
aS'from mx.DateTime.ISO import ParseDateTimeUTC'
p5786
aS"from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p5787
aS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p5788
aS'import datetime\ndatetime.datetime.now().isoformat()'
p5789
aS"x = ParseDateTimeUTC('2010-06-04 21:08:12')"
p5790
aS"class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p5791
aS'from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime'
p5792
aS'from time import strftime'
p5793
aS'import datetime\ndatetime.datetime.utcnow().isoformat()'
p5794
atp5795
Rp5796
sI1186789
g1
((lp5797
S"print 'test1.py'"
p5798
aS'import test1\n\ndef service_func():\n    pass'
p5799
aS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p5800
aS"print 'service func'"
p5801
aS'import subprocess'
p5802
aS"def service_func():\n    print 'service func'"
p5803
aS'def service_func():\n    pass'
p5804
aS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    some_func()"
p5805
aS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p5806
aS"if (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p5807
aS"if (__name__ == '__main__'):\n    service_func()"
p5808
aS'service_func()'
p5809
aS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p5810
aS"import subprocess\nsubprocess.call('test1.py', shell=True)"
p5811
aS'some_func()'
p5812
aS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    pass"
p5813
aS'test1.some_func()'
p5814
aS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p5815
aS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p5816
aS"if (__name__ == '__main__'):\n    some_func()"
p5817
aS"print 'in test 1, unproductive'"
p5818
aS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p5819
aS'import test1'
p5820
aS'def some_func():\n    pass'
p5821
aS"if (__name__ == '__main__'):\n    pass"
p5822
aS"subprocess.call('test1.py', shell=True)"
p5823
aS"execfile('test2.py')"
p5824
aS"def some_func():\n    print 'in test 1, unproductive'"
p5825
aS"import test1\n\ndef service_func():\n    print 'service func'"
p5826
atp5827
Rp5828
sI1747817
g1
((lp5829
S'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p5830
aS'def key_value_gen(k):\n    pass'
p5831
aS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p5832
aS'yield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p5833
aS'yield chr((k + 65))'
p5834
aS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p5835
aS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p5836
aS'dict(gen)'
p5837
aS'd = {key: value for (key, value) in iterable}'
p5838
aS'dict(ts)'
p5839
aS'gen\ndict(gen)'
p5840
aS'yield chr((((k + 13) % 26) + 65))'
p5841
aS'def key_value_gen(k):\n    yield chr((k + 65))'
p5842
aS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p5843
aS'gen'
p5844
aS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)'
p5845
aS'd = {k: v for (k, v) in iterable}'
p5846
aS'd = dict(map(key_value_gen, range(26)))'
p5847
aS'ts = [(1, 2), (3, 4), (5, 6)]'
p5848
aS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p5849
aS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p5850
aS'gen = ((i, (i + 1)) for i in range(1, 6, 2))'
p5851
aS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p5852
aS'd = dict(((key, value) for (key, value) in iterable))'
p5853
aS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))'
p5854
aS'd = {value: foo(value) for value in sequence if bar(value)}'
p5855
aS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p5856
aS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p5857
aS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p5858
aS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p5859
aS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    pass'
p5860
atp5861
Rp5862
sI2793324
g1
((lp5863
S'a = [x for x in a if (x != 2)]\nprint a'
p5864
aS'a = [1, 2, 3, 4]'
p5865
aS'a = [1, 2, 3, 4]\nif (6 in a):\n    a.remove(6)'
p5866
aS'if (c in a):\n    a.remove(c)'
p5867
aS"a.remove('b')\nprint a"
p5868
aS'a.remove(c)'
p5869
aS'a = [1, 2, 3, 4]\nif (6 in a):\n    pass'
p5870
aS'pass'
p5871
aS"a = ['a', 'b', 'c', 'd']\na.remove('b')"
p5872
aS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]'
p5873
aS'if (c in a):\n    pass'
p5874
aS'print a'
p5875
aS'try:\n    a.remove(6)\nexcept:\n    pass'
p5876
aS'try:\n    a.remove(c)\nexcept ValueError:\n    pass'
p5877
aS"a.remove('b')"
p5878
aS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]'
p5879
aS'if (6 in a):\n    pass'
p5880
aS'a.remove(6)'
p5881
aS'if (6 in a):\n    a.remove(6)'
p5882
aS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]\nprint a'
p5883
aS"a = ['a', 'b', 'c', 'd']"
p5884
aS'a = [x for x in a if (x != 2)]'
p5885
aS"a = ['a', 'b', 'c', 'd']\na.remove('b')\nprint a"
p5886
atp5887
Rp5888
sI123198
g1
((lp5889
S'from shutil import copyfile\ncopyfile(src, dst)'
p5890
aS"shutil.copy2('/dir/file.ext', '/new/dir')"
p5891
aS"shutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p5892
aS'from shutil import copyfile'
p5893
aS'copyfile(src, dst)'
p5894
aS"import shutil\nshutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p5895
aS'import shutil'
p5896
atp5897
Rp5898
sI1602934
g1
((lp5899
S'from collections import defaultdict\nd = defaultdict((lambda : 0))'
p5900
aS'key = (i % 10)'
p5901
aS"('a' in d)\n('c' in d)"
p5902
aS'for i in xrange(100):\n    d[(i % 10)] += 1'
p5903
aS'd = defaultdict((lambda : 0))'
p5904
aS'd[key] = 1'
p5905
aS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p5906
aS'd = dict()\nfor i in xrange(100):\n    pass'
p5907
aS"d = {'a': 1, 'b': 2, }"
p5908
aS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p5909
aS'if (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p5910
aS"if ('key1' in dict):\n    print 'blah'\nelse:\n    print 'boo'"
p5911
aS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p5912
aS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p5913
aS'if (key in d):\n    d[key] += 1'
p5914
aS'd[key] += 1'
p5915
aS"d = {'a': 1, 'b': 2, }\n('a' in d)"
p5916
aS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)'
p5917
aS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p5918
aS'd = dict()'
p5919
aS"if ('key1' in dict):\n    pass"
p5920
aS"('a' in d)"
p5921
aS"if ('key1' in dict):\n    print 'blah'\nelse:\n    pass"
p5922
aS'for i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p5923
aS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p5924
aS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p5925
aS'from collections import defaultdict'
p5926
aS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p5927
aS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p5928
aS'for i in xrange(100):\n    pass'
p5929
aS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p5930
aS'for i in xrange(100):\n    key = (i % 10)'
p5931
aS"d = {'a': 1, 'b': 2, }\n('a' in d)\n('c' in d)"
p5932
aS'd[key] = (d.get(key, 0) + 1)'
p5933
aS"print 'blah'"
p5934
aS"('c' in d)"
p5935
aS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p5936
aS'd[(i % 10)] += 1'
p5937
aS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p5938
aS'if (key in d):\n    pass'
p5939
aS'if (key in d):\n    d[key] += 1\nelse:\n    pass'
p5940
aS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p5941
aS"print 'boo'"
p5942
atp5943
Rp5944
sI9573244
g1
((lp5945
S'if (not my_string):\n    pass'
p5946
aS"bool('   '.strip())"
p5947
aS"bool('')\nbool('   ')"
p5948
aS'if some_string:\n    pass'
p5949
aS'if (not myString):\n    pass'
p5950
aS'if (not some_string):\n    pass'
p5951
aS"bool('   ')\nbool('   '.strip())"
p5952
aS'pass'
p5953
aS"bool('')\nbool('   ')\nbool('   '.strip())"
p5954
aS"bool('   ')"
p5955
aS"bool('')"
p5956
atp5957
Rp5958
sI743806
g1
((lp5959
S"words = text.split(',')"
p5960
aS"line = 'a sentence with a few words'\nline.split()"
p5961
aS'words = text.split()'
p5962
aS'line.split()'
p5963
aS'word.append(words)'
p5964
aS"line = 'a sentence with a few words'"
p5965
aS'words.append(word)'
p5966
aS'text.split()'
p5967
atp5968
Rp5969
sI518021
g1
((lp5970
S"s = 'abcde'"
p5971
aS'my_tuple = (1, 2, 3, 4, 5)\nlen(my_tuple)'
p5972
aS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)"
p5973
aS"l = [1, 2, 3, 4]\ns = 'abcde'"
p5974
aS'len(my_list)'
p5975
aS"s = 'abcde'\nlen(l)"
p5976
aS'my_tuple = (1, 2, 3, 4, 5)'
p5977
aS'len(my_string)'
p5978
aS'len(l)\nlen(s)'
p5979
aS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)\nlen(s)"
p5980
aS'len(l)'
p5981
aS'my_list = [1, 2, 3, 4, 5]\nlen(my_list)'
p5982
aS"my_string = 'hello world'"
p5983
aS"my_string = 'hello world'\nlen(my_string)"
p5984
aS"s = 'abcde'\nlen(l)\nlen(s)"
p5985
aS'my_list = [1, 2, 3, 4, 5]'
p5986
aS'l = [1, 2, 3, 4]'
p5987
aS'len(my_tuple)'
p5988
aS'len(s)'
p5989
atp5990
Rp5991
sI510348
g1
((lp5992
S"import time\nwhile True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p5993
aS'time.sleep(60)'
p5994
aS'from time import sleep'
p5995
aS"print 'This prints once a minute.'"
p5996
aS'import time'
p5997
aS'time.sleep(5)'
p5998
aS'sleep(0.1)'
p5999
aS'import time\ntime.sleep(60)'
p6000
aS'import time\ntime.sleep(5)'
p6001
aS'from time import sleep\nsleep(0.1)'
p6002
aS'while True:\n    pass'
p6003
aS'time.sleep(0.1)'
p6004
aS"while True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p6005
aS'import time\ntime.sleep(0.1)'
p6006
aS'import time\nwhile True:\n    pass'
p6007
aS'time.sleep(time.localtime(time.time())[5])'
p6008
atp6009
Rp6010
sI82831
g1
((lp6011
S"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p6012
aS"print os.path.isfile('/etc')"
p6013
aS"my_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p6014
aS"print os.path.exists('/etc/password.txt')"
p6015
aS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p6016
aS'import os.path'
p6017
aS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p6018
aS'import os.path\nos.path.exists(file_path)'
p6019
aS'pass'
p6020
aS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p6021
aS"from pathlib import Path\nmy_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p6022
aS"print os.path.isfile('/does/not/exist')"
p6023
aS"from pathlib import Path\nmy_file = Path('/path/to/file')"
p6024
aS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p6025
aS'from pathlib import Path'
p6026
aS'os.path.isfile(fname)'
p6027
aS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p6028
aS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')"
p6029
aS"print os.path.exists('/etc')"
p6030
aS"my_file = Path('/path/to/file')"
p6031
aS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p6032
aS'if my_file.is_file():\n    pass'
p6033
aS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p6034
aS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p6035
aS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p6036
aS"print os.path.exists('/does/not/exist')"
p6037
aS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p6038
aS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p6039
aS'import os.path\nos.path.isfile(fname)'
p6040
aS"print os.path.isfile('/etc/password.txt')"
p6041
aS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p6042
aS'os.path.exists(file_path)'
p6043
aS"print os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p6044
atp6045
Rp6046
sI510357
g1
((lp6047
S'import sys, tty'
p6048
aS'def _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p6049
aS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p6050
aS'return ch\nreturn _getch'
p6051
aS'return _getch'
p6052
aS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p6053
aS'tty.setraw(fd)'
p6054
aS'tty.setraw(sys.stdin.fileno())'
p6055
aS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p6056
aS'ch = sys.stdin.read(1)'
p6057
aS'old_settings = termios.tcgetattr(fd)'
p6058
aS'def __call__(self):\n    import sys, tty, termios'
p6059
aS'def _getch():\n    fd = sys.stdin.fileno()'
p6060
aS'def __init__(self):\n    import tty, sys'
p6061
aS'def __init__(self):\n    import msvcrt'
p6062
aS'getch = _find_getch()'
p6063
aS'return ch\nreturn _getch\ngetch = _find_getch()'
p6064
aS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p6065
aS'def __call__(self):\n    pass'
p6066
aS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p6067
aS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p6068
aS'class _GetchWindows:\n\n    def __init__(self):\n        pass'
p6069
aS'import termios'
p6070
aS'return ch\n\n\nclass _GetchWindows:\n    pass'
p6071
aS'getch = _Getch()'
p6072
aS'class _GetchUnix:\n\n    def __init__(self):\n        pass'
p6073
aS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p6074
aS'self.impl = _GetchUnix()'
p6075
aS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p6076
aS'def __call__(self):\n    return self.impl()'
p6077
aS'return msvcrt.getch()'
p6078
aS'import tty, sys'
p6079
aS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p6080
aS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p6081
aS"'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p6082
aS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p6083
aS'def __init__(self):\n    pass'
p6084
aS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p6085
aS'termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)'
p6086
aS'import sys, tty\n\ndef _getch():\n    pass'
p6087
aS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p6088
aS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p6089
aS'fd = sys.stdin.fileno()'
p6090
aS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p6091
aS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p6092
aS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p6093
aS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p6094
aS'class _Getch:\n    pass'
p6095
aS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p6096
aS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'"
p6097
aS'return self.impl()'
p6098
aS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p6099
aS'return msvcrt.getch'
p6100
aS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p6101
aS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p6102
aS'def __call__(self):\n    import msvcrt'
p6103
aS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p6104
aS'return _getch\ngetch = _find_getch()'
p6105
aS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'\n\ndef __init__(self):\n    pass"
p6106
aS'sys.stdin.read(1)'
p6107
aS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        pass'
p6108
aS'self.impl = _GetchWindows()'
p6109
aS'class _GetchUnix:\n    pass'
p6110
aS'def _getch():\n    pass'
p6111
aS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p6112
aS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p6113
aS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    pass'
p6114
aS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p6115
aS'fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p6116
aS'def _find_getch():\n    pass'
p6117
aS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p6118
aS'return msvcrt.getch\nimport sys, tty'
p6119
aS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p6120
aS"'Gets a single character from standard input.  Does not echo to the screen.'"
p6121
aS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p6122
aS'class _GetchWindows:\n    pass'
p6123
aS'import sys, tty, termios'
p6124
aS'return ch'
p6125
aS'import msvcrt'
p6126
aS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'\n\ndef __init__(self):\n    pass"
p6127
aS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        pass'
p6128
aS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n    pass'
p6129
aS'return msvcrt.getch()\ngetch = _Getch()'
p6130
atp6131
Rp6132
sI1450393
g1
((lp6133
S'for line in fileinput.input():\n    pass'
p6134
aS'import sys'
p6135
aS'print line'
p6136
aS'for line in sys.stdin:\n    pass'
p6137
aS'import fileinput\nfor line in fileinput.input():\n    pass'
p6138
aS'import fileinput'
p6139
aS'pass'
p6140
aS'import sys\nfor line in sys.stdin:\n    pass'
p6141
atp6142
Rp6143
sI15411107
g1
((lp6144
S'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: mydict[k] for k in keys_to_keep}'
p6145
aS'for key in keys_to_remove:\n    pass'
p6146
aS'new_dict = {k: mydict[k] for k in keys_to_keep}'
p6147
aS'try:\n    del mydict[key]\nexcept KeyError:\n    pass'
p6148
aS'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p6149
aS'for key in keys_to_remove:\n    del mydict[key]'
p6150
aS'pass'
p6151
aS'new_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p6152
aS'keys_to_keep = (set(mydict.keys()) - set(keys))'
p6153
aS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    pass'
p6154
aS'del mydict[key]'
p6155
aS'keys_to_remove = set(keys).intersection(set(mydict.keys()))'
p6156
aS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    del mydict[key]'
p6157
aS"mydict.pop('key', None)"
p6158
atp6159
Rp6160
sI466345
g1
((lp6161
S'from datetime import datetime'
p6162
aS"from datetime import datetime\ndate_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p6163
aS"date_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p6164
aS"dt = parser.parse('Aug 28 1999 12:00AM')"
p6165
aS'from dateutil import parser'
p6166
aS"from dateutil import parser\ndt = parser.parse('Aug 28 1999 12:00AM')"
p6167
atp6168
Rp6169
sI8177079
g1
((lp6170
S'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p6171
aS'c.extend(a)'
p6172
aS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p6173
aS'a = range(5)'
p6174
aS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p6175
aS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p6176
aS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p6177
aS'pass'
p6178
aS'for logs in mydir:\n    for line in mylog:\n        list1.append(line)'
p6179
aS'list1.append(line)'
p6180
aS'c.extend(a)\nc'
p6181
aS'b\nc.extend(a)'
p6182
aS"import itertools\np = ['a', 'b', 'c']"
p6183
aS'for logs in mydir:\n    pass'
p6184
aS'b.append(a)\nb'
p6185
aS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p6186
aS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)'
p6187
aS'for line in mylog:\n    pass'
p6188
aS'c = range(2)\nb.append(a)\nb\nc.extend(a)'
p6189
aS'b.append(a)\nb\nc.extend(a)'
p6190
aS'c = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p6191
aS'for x in itertools.chain(p, q, r):\n    pass'
p6192
aS"r = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p6193
aS'c = range(2)\nb.append(a)'
p6194
aS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    pass"
p6195
aS'a = range(5)\nb = range(3)'
p6196
aS"p = ['a', 'b', 'c']"
p6197
aS'list1.extend(mylog)'
p6198
aS'for line in mylog:\n    list1.append(line)'
p6199
aS'b.append(a)\nb\nc.extend(a)\nc'
p6200
aS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p6201
aS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb'
p6202
aS'list2.extend(list1)'
p6203
aS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p6204
aS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p6205
aS'for logs in mydir:\n    for line in mylog:\n        pass'
p6206
aS'list2.append(list1)'
p6207
aS'c = range(2)\nb.append(a)\nb'
p6208
aS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p6209
aS'b = range(3)\nc = range(2)\nb.append(a)\nb'
p6210
aS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p6211
aS'b.append(a)'
p6212
aS'import itertools'
p6213
aS"if any((True for line in list1 if ('string' in line))):\n    pass"
p6214
aS"r = ['g', 'h', 'i']"
p6215
aS'c'
p6216
aS'b'
p6217
aS'b = range(3)'
p6218
aS'c = range(2)'
p6219
aS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p6220
aS'b = range(3)\nc = range(2)\nb.append(a)'
p6221
aS'b = range(3)\nc = range(2)'
p6222
aS'b\nc.extend(a)\nc'
p6223
aS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p6224
aS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p6225
aS"q = ['d', 'e', 'f']"
p6226
aS'a = range(5)\nb = range(3)\nc = range(2)'
p6227
aS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p6228
aS'del list1'
p6229
aS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p6230
atp6231
Rp6232
sI455612
g1
((lp6233
S"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p6234
aS'x = 13.95'
p6235
aS'g\n(x == g)\nh = round(x, 2)\nh\n(x == h)'
p6236
aS"g = float('{0:.2f}'.format(x))\ng\n(x == g)"
p6237
aS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p6238
aS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p6239
aS"x\ng = float('{0:.2f}'.format(x))\ng"
p6240
aS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p6241
aS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p6242
aS"print ('%.2f' % round(a, 2))"
p6243
aS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6244
aS'(125650429603636838 / (2 ** 53))'
p6245
aS"print '{0:.15f}'.format(round(a, 2))"
p6246
aS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng"
p6247
aS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p6248
aS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))'
p6249
aS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6250
aS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6251
aS'round(a, 2)'
p6252
aS'a = 13.946\nprint a'
p6253
aS"print a\nprint ('%.2f' % a)"
p6254
aS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p6255
aS'(x == h)'
p6256
aS"round(a, 2)\nprint ('%.2f' % round(a, 2))"
p6257
aS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p6258
aS'(234042163 / (2 ** 24))\na = 13.946\nprint a'
p6259
aS"print '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6260
aS"x\ng = float('{0:.2f}'.format(x))"
p6261
aS"float('{0:.2f}'.format(13.95))"
p6262
aS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p6263
aS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946'
p6264
aS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p6265
aS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p6266
aS"g = float('{0:.2f}'.format(x))"
p6267
aS"('%.2f' % 3.14159)\n('%.2f' % 13.9499999)"
p6268
aS"print '{0:.2f}'.format(round(a, 2))"
p6269
aS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p6270
aS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p6271
aS'(x == g)\nh = round(x, 2)\nh'
p6272
aS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6273
aS'(234042163 / (2 ** 24))\na = 13.946'
p6274
aS'h'
p6275
aS'h\n(x == h)'
p6276
aS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p6277
aS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6278
aS'g\n(x == g)\nh = round(x, 2)\nh'
p6279
aS"print ('%.2f' % a)"
p6280
aS'(x == g)'
p6281
aS'x'
p6282
aS"print ('%.2f' % a)\nround(a, 2)"
p6283
aS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))"
p6284
aS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6285
aS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)"
p6286
aS"g = float('{0:.2f}'.format(x))\ng"
p6287
aS'a = 13.946'
p6288
aS"('%.2f' % 13.9499999)"
p6289
aS'g\n(x == g)\nh = round(x, 2)'
p6290
aS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p6291
aS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p6292
aS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p6293
aS'print a'
p6294
aS'(x == g)\nh = round(x, 2)'
p6295
aS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p6296
aS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6297
aS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p6298
aS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6299
aS"a = 13.946\nprint a\nprint ('%.2f' % a)"
p6300
aS'x = 13.95\nx'
p6301
aS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6302
aS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)"
p6303
aS'h = round(x, 2)'
p6304
aS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p6305
aS'(234042163 / (2 ** 24))'
p6306
aS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p6307
aS"'{0:.2f}'.format(13.95)"
p6308
aS'(x == g)\nh = round(x, 2)\nh\n(x == h)'
p6309
aS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p6310
aS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p6311
aS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p6312
aS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6313
aS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6314
aS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6315
aS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6316
aS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p6317
aS'g'
p6318
aS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6319
aS"print '{0:.2f}'.format(a)"
p6320
aS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p6321
aS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p6322
aS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a'
p6323
aS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p6324
aS'h = round(x, 2)\nh'
p6325
aS"('%.2f' % 3.14159)"
p6326
aS'h = round(x, 2)\nh\n(x == h)'
p6327
aS"print a\nprint ('%.2f' % a)\nround(a, 2)"
p6328
aS'g\n(x == g)'
p6329
atp6330
Rp6331
sI73663
g1
((lp6332
S'sys.exit()'
p6333
aS'if (this == that):\n    pass'
p6334
aS'import sys'
p6335
aS'quit()'
p6336
aS'raise SystemExit'
p6337
aS'if (this == that):\n    quit()'
p6338
aS'import sys\nsys.exit()'
p6339
atp6340
Rp6341
sI1476
g1
((lp6342
S"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))"
p6343
aS"int('010101', 2)"
p6344
aS'21'
p6345
aS"int('10101', 0)\nint('0b10101', 0)"
p6346
aS'bin(21)'
p6347
aS'47'
p6348
aS"int('0b10101', 0)"
p6349
aS"print int('01010101111', 2)"
p6350
aS"int('0b0010101010', 2)"
p6351
aS"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))\nformat(int('010101', 2), '010b')"
p6352
aS'170\n21'
p6353
aS'bin(173)'
p6354
aS"int('10101', 0)"
p6355
aS"format(int('010101', 2), '010b')"
p6356
aS"bin(int('010101', 2))"
p6357
aS"print int('01010101111', 2)\nprint int('11111111', 2)"
p6358
aS"print int('11111111', 2)"
p6359
aS'170'
p6360
atp6361
Rp6362
sI761804
g1
((lp6363
S"'          Hello        '.strip()"
p6364
aS"strip_one_space('   Hello ')"
p6365
aS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p6366
aS"' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p6367
aS"title = title.strip(',.-')"
p6368
aS"' Hello'.strip()"
p6369
aS'myString.strip()'
p6370
aS"'Bob has a cat'.strip()"
p6371
aS"'Bob has a cat'.strip()\n'          Hello        '.strip()"
p6372
aS"' Hello '.strip()\n' Hello'.strip()"
p6373
aS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()"
p6374
aS"' Hello'.strip()\n'Bob has a cat'.strip()"
p6375
aS"' Hello '.strip()"
p6376
aS"'  Hello\\n'.strip(' ')"
p6377
atp6378
Rp6379
sI4476373
g1
((lp6380
S"payload = {'key1': 'value1', 'key2': 'value2', }"
p6381
aS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p6382
aS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p6383
aS'r = requests.post(url, data=payload)\nimport json'
p6384
aS'resp'
p6385
aS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p6386
aS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p6387
aS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p6388
aS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p6389
aS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        return urllib2.Request(url, data=urllib.urlencode(params))"
p6390
aS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p6391
aS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p6392
aS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p6393
aS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        pass"
p6394
aS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p6395
aS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p6396
aS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p6397
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p6398
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p6399
aS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p6400
aS'r.text'
p6401
aS"post_data = {'username': 'joeb', 'password': 'foobar', }"
p6402
aS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p6403
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p6404
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p6405
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p6406
aS'from httplib2 import Http\nfrom urllib import urlencode'
p6407
aS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p6408
aS'r = requests.post(url, data=json.dumps(payload))\nr.text'
p6409
aS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p6410
aS"return urllib2.Request(((url + '?') + urllib.urlencode(params)))"
p6411
aS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p6412
aS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p6413
aS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p6414
aS'import json\nr = requests.post(url, data=json.dumps(payload))'
p6415
aS"import requests\nget_response = requests.get(url='http://google.com')"
p6416
aS'r = requests.post(url, data=json.dumps(payload))'
p6417
aS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p6418
aS'from httplib2 import Http\nfrom urllib import urlencode\nh = Http()'
p6419
aS'import requests'
p6420
aS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p6421
aS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p6422
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p6423
aS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p6424
aS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p6425
aS"import requests\nurl = 'https://...'"
p6426
aS"if (method == 'POST'):\n    pass"
p6427
aS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p6428
aS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p6429
aS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p6430
aS'return urllib2.Request(url, data=urllib.urlencode(params))'
p6431
aS'import json'
p6432
aS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p6433
aS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p6434
aS'r = requests.get(url)'
p6435
aS"post_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p6436
aS"get_response = requests.get(url='http://google.com')"
p6437
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p6438
aS"post_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p6439
aS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p6440
aS"def URLRequest(url, params, method='GET'):\n    pass"
p6441
aS"url = 'https://...'"
p6442
aS'r.status_code'
p6443
aS'from httplib2 import Http'
p6444
aS"h = Http()\ndata = dict(name='Joe', comment='A test comment')"
p6445
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p6446
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p6447
aS'r = requests.get(url, params=payload)'
p6448
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p6449
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p6450
aS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p6451
aS'r = requests.post(url, data=payload)'
p6452
aS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p6453
aS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p6454
aS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p6455
aS'from urllib import urlencode\nh = Http()'
p6456
aS'h = Http()'
p6457
aS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p6458
aS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p6459
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p6460
aS'from urllib import urlencode'
p6461
aS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p6462
aS'r = requests.get(url)\nr = requests.get(url, params=payload)'
p6463
aS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p6464
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p6465
aS"data = dict(name='Joe', comment='A test comment')"
p6466
aS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p6467
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p6468
aS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p6469
aS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p6470
aS"if (method == 'POST'):\n    return urllib2.Request(url, data=urllib.urlencode(params))"
p6471
aS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p6472
aS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p6473
aS'r = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p6474
aS'r.text\nr.status_code'
p6475
aS"post_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p6476
aS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p6477
atp6478
Rp6479
sI247770
g1
((lp6480
S'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p6481
aS'import bar'
p6482
aS'import inspect\ninspect.getfile(os)'
p6483
aS'path = os.path.dirname(amodule.__file__)'
p6484
aS'print bar.__file__'
p6485
aS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p6486
aS'import a_module'
p6487
aS'import os'
p6488
aS'print os.getcwd()'
p6489
aS'inspect.getfile(os)\ninspect.getfile(inspect)'
p6490
aS'import os\nprint os.getcwd()\nprint __file__'
p6491
aS'import os\nimport inspect'
p6492
aS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p6493
aS'path = os.path.abspath(amodule.__file__)'
p6494
aS'import inspect'
p6495
aS'inspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p6496
aS'import a_module\nprint a_module.__file__'
p6497
aS'inspect.getfile(os)'
p6498
aS'print a_module.__file__'
p6499
aS'import os\npath = os.path.dirname(amodule.__file__)'
p6500
aS'print __file__'
p6501
aS'import os\nprint os.getcwd()'
p6502
aS'os.path.dirname(inspect.getfile(inspect))'
p6503
aS'import bar\nprint bar.__file__'
p6504
aS'inspect.getfile(inspect)'
p6505
aS'import os\nimport inspect\ninspect.getfile(os)'
p6506
aS'inspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p6507
aS'print os.getcwd()\nprint __file__'
p6508
aS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p6509
atp6510
Rp6511
sI4906977
g1
((lp6512
S'print os.environ'
p6513
aS"print os.environ.get('KEY_THAT_MIGHT_EXIST')\nprint os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p6514
aS"print os.environ.get('KEY_THAT_MIGHT_EXIST')"
p6515
aS'import sys'
p6516
aS'import os\nprint os.environ'
p6517
aS"('HOME' in os.environ)"
p6518
aS'print sys.prefix'
p6519
aS"import os\nprint os.environ['HOME']"
p6520
aS'os.environ'
p6521
aS"os.environ.has_key('HOME')"
p6522
aS'import os'
p6523
aS"print os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p6524
aS"print os.environ.get('HOME', '/home/username/')"
p6525
aS"print os.environ['HOME']"
p6526
aS'import sys\nprint sys.prefix'
p6527
atp6528
Rp6529
sI4641765
g1
((lp6530
S'things_to_add = [0, 1, 1, 0]'
p6531
aS'fooList.append(3)\nfooList.append(2734)\nprint fooList'
p6532
aS'print fooList'
p6533
aS'foo.append(4)\nfoo.append([8, 7])\nprint foo'
p6534
aS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]'
p6535
aS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p6536
aS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p6537
aS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p6538
aS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p6539
aS'foo[3] = (foo[3] + 4)\nprint foo'
p6540
aS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)\nprint fooList'
p6541
aS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p6542
aS'fooList.append(3)\nfooList.append(2734)'
p6543
aS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])'
p6544
aS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p6545
aS'foo.append([8, 7])\nprint foo'
p6546
aS'fooList = [1, 3, 348, 2]\nfooList.append(3)'
p6547
aS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)'
p6548
aS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])\nprint foo'
p6549
aS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p6550
aS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p6551
aS'print foo'
p6552
aS'foo.append(4)'
p6553
aS'foo = [1, 2, 3, 4, 5]'
p6554
aS'print x'
p6555
aS'fooList = [1, 3, 348, 2]'
p6556
aS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p6557
aS'fooList.append(3)'
p6558
aS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)'
p6559
aS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p6560
aS'L[idx] += amount'
p6561
aS'foo.append([8, 7])'
p6562
aS'fooList.append(2734)\nprint fooList'
p6563
aS'L'
p6564
aS'foo.append(4)\nfoo.append([8, 7])'
p6565
aS'for (idx, amount) in things_to_add:\n    L[idx] += amount'
p6566
aS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p6567
aS'x = [2, 5, 10]\nx.insert(2, 77)'
p6568
aS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount'
p6569
aS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p6570
aS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p6571
aS"for item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p6572
aS'L[:] = [sum(i) for i in zip(L, things_to_add)]'
p6573
aS'x.insert(2, 77)\nprint x'
p6574
aS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p6575
aS'for (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p6576
aS'things_to_add = [(1, 1), (2, 1)]'
p6577
aS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)\nprint foo'
p6578
aS"for item in things_to_add:\n    L[item['idx']] += item['amount']"
p6579
aS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p6580
aS'for item in things_to_add:\n    pass'
p6581
aS"L[item['idx']] += item['amount']"
p6582
aS'for (idx, amount) in things_to_add:\n    pass'
p6583
aS'x = [2, 5, 10]'
p6584
aS'foo[3] = (foo[3] + 4)'
p6585
aS'x.insert(2, 77)'
p6586
aS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    pass'
p6587
aS'L = [0, 0, 0, 0]'
p6588
aS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p6589
aS'x = [2, 5, 10]\nx.insert(2, 77)\nprint x'
p6590
aS'fooList.append(2734)'
p6591
aS'for (idx, amount) in enumerate(things_to_add):\n    pass'
p6592
aS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)'
p6593
aS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p6594
atp6595
Rp6596
sI2407398
g1
((lp6597
S'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]'
p6598
aS'zip(list_a, list_b)'
p6599
aS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p6600
aS'list_a = [1, 2, 3, 4]'
p6601
aS'list_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p6602
aS'list_b = [5, 6, 7, 8]'
p6603
atp6604
Rp6605
sI19602931
g1
((lp6606
S'testfile = urllib.URLopener()'
p6607
aS'file_name = wget.download(file_url)'
p6608
aS'import urllib\ntestfile = urllib.URLopener()'
p6609
aS"testfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p6610
aS"import wget\nfile_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p6611
aS"urllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p6612
aS"file_url = 'http://johndoe.com/download.zip'"
p6613
aS'import wget'
p6614
aS"testfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p6615
aS"file_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p6616
aS"import wget\nfile_url = 'http://johndoe.com/download.zip'"
p6617
aS'import urllib'
p6618
aS"import urllib\nurllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p6619
aS"import urllib\ntestfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p6620
atp6621
Rp6622
sI4588628
g1
((lp6623
S'(a == 0)'
p6624
aS'numpy.where((x == 0))[0]'
p6625
aS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\nnumpy.where((x == 0))[0]'
p6626
aS'a = np.asarray([0, 1, 2, 3, 4])\n(a == 0)'
p6627
aS'(x == 0)\nnumpy.nonzero((x == 0))[0]'
p6628
aS'numpy.nonzero((x == 0))[0]'
p6629
aS'a = np.asarray([0, 1, 2, 3, 4])'
p6630
aS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])'
p6631
aS'(x == 0)'
p6632
aS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)'
p6633
aS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)\nnumpy.nonzero((x == 0))[0]'
p6634
atp6635
Rp6636
s.